/**
 * Interjs 
 * Version - 2.0.16
 * MIT LICENSED BY - Denis Power
 * Repo - https://github.com/interjs/inter
 * 2021-2022
 * GENERATED BY INTER GLOBAL BUILDER
 * 
 * 
 * 
 */

!function(){function e(e){return n(e)&&e.element&&e[Symbol.for("template")]}function t(e){return Object.isFrozen(e)||Object.isSealed(e)||!Object.isExtensible(e)}function n(e){return"[object Object]"==Object.prototype.toString.apply(e,void 0)}function r(e){return e instanceof Set}function o(e){return e instanceof Map}function s(e){return null!=e}function i(e){return Object.is(e,!0)}function a(e){return Object.is(e,!1)}function c(e){return"function"==typeof e}function l(e){return e instanceof HTMLElement}function f(e){return s(e)&&(1==e.nodeType||3==e.nodeType)}function u(e){return e in HTMLElement.prototype}function d(e){return e in document.createElement("p").style}function h(e){return document.createTextNode(e)}function p(e){return"string"==typeof e}function b(e){return n(e)}function m(e){"string"!=typeof e&&g("\n            \n            The value of the id attribute must be a string.\n            \n            ");const t=document.getElementById(e);if(null!=t)return t;w(`\n            \n            There's not an element on the document with the id\t\n\t\t\tattribute whose value is "${e}".\n    \n            `)}function y(e){return void 0===e||"symbol"==typeof e||"bigint"==typeof e||"boolean"==typeof e||"function"==typeof e||"number"==typeof e||"string"==typeof e?typeof e:function(e){return s(e)&&Object.prototype.toString.call(e).startsWith("[object")?Object.prototype.toString.call(e).replace("[object","").replace("]","").replace(/\s/g,"").toLowerCase():"null"}(e)}function g(e){throw new SyntaxError(`\n        \n        Inter syntaxError : ${e}\n        \n        `)}function w(e){throw new Error(`\n        \n        Inter error: ${e}\n        \n        `)}function j(e){console.warn(`\n        Inter warning: ${e}\n        \n        `)}function T(e){console.error(`\n    \n       Inter parser error: ${e}\n        \n        `)}function A(e){return Array.isArray(e)}function O(e){return 1==e||0==e}function x(e){return e instanceof Array||n(e)||e instanceof Map||e instanceof Set||"number"==typeof e}function $(e){this.source=function(e){const t={values:new Array,type:void 0};if(A(e))t.values=e,t.type="array";else if(n(e))t.values=Object.entries(e),t.type="object";else if(e instanceof Map)e.forEach(((e,n)=>{t.values.push([n,e])})),t.type="object";else if(e instanceof Set)t.values=Array.from(e),t.type="set";else if("number"==typeof e){for(let n=0;n<e;n++)t.values.push(n);t.type="number"}return t}(e)}function C(e){j(`"${e}" is a reserved property you can not use it as a\n\treference name`)}function S(e){const t=new Set;return e.replace(/{\s*(:?[\w-\s]+)\s*}/g,(e=>{const n=e.replace("{","").replace("}","").trim();t.add(n)})),Array.from(t)}$.prototype.each=function(e){let t=-1;for(const n of this.source.values)t++,e(n,t,this.source.type)};const N=new Set(["currentTime","value"]);function k(e,t,n){function r(e){let t=new Set;if(e.hasChildNodes())for(let r of e.childNodes)3==r.nodeType&&r.textContent.trim().length>0&&(n=r.textContent,/{\s*.*\s*}/.test(n))&&t.add(r);var n;return Array.from(t)}const o=e.getElementsByTagName("*");function s(e){function r(e){for(let r in t){const t=new RegExp(`{\\s*${r}\\s*}`);if(!e.ref&&e.textContent.trim().length>0&&t.test(e.textContent)){const t={target:e,text:e.textContent};n.add(t)}}}if(1==e.nodeType)for(let t of e.childNodes)t.hasChildNodes()&&1==t.nodeType?s(t):r(t);else 3==e.nodeType&&r(e)}if(r(e).length>0)for(let t of r(e))s(t);for(const e of o){const r={target:e,attrs:Object.create(null),refs:t};for(const o of e.attributes)for(const s in t){new RegExp(`{\\s*${s}\\s*}`).test(o.value)&&(N.has(o.name)?n.specialAttrs.add({target:e,attr:{[o.name]:o.value}}):r.attrs[o.name]=o.value)}if(i=r.attrs,Object.keys(i).length>0&&n.add(r,!0),e.hasChildNodes()){const r=e.childNodes;for(const e of r)if(e.hasChildNodes())s(e);else for(const r in t){const t=new RegExp(`{\\s*${r}\\s*}`);if(!e.ref&&e.textContent.trim().length>0&&t.test(e.textContent)){const t={target:e,text:e.textContent};n.add(t)}}}else{const r=e.textContent,o={target:e,text:r};for(let s in t){const t=new RegExp(`{\\s*${s}\\s*}`);!e.ref&&t.test(r)&&n.add(o)}}}var i;n.update()}function P(e){const t=new Array;return e.childNodes.forEach(((e,n)=>{(1==e.nodeType||3==e.nodeType&&0==!e.textContent.trim().length)&&(null==e.index&&(e.index=n),t.push(e))})),t}function E(e){j(`"${e}" is a reserved property, you can not use it as a conditional property.`)}function R(e){j(`${e} is a reserved Attribute name.`)}function I(e,t,r){const o=new Set(["value","currentTime"]),s=new Set(["setAttrs"]);function i(t,n){null==(t=c(t)?t.call(r):t)?n.startsWith("on")?e[n]=void 0:e.removeAttribute(n):n.startsWith("on")||o.has(n)?o.has(n)?e[n]=t:n.startsWith("On")&&(u(n)?(c(t)||g(`\n                        The value of the "${n}" event must be a function.\n                        `),e[n]=function(e){v.call(original,e)}):j(`\n                    \n                    "${n}" doesn't seem to be a valid dom event.\n                    \n                    `)):e.setAttribute(n,t)}function a(t){Object.defineProperty(r,t,{set(e){i(e,t)},get:()=>(t.startsWith("on")&&j(`\n                       "${t}" seems to be an event listener, \n                       and you can not get the value of an event.\n                       `),o.has(t)?e[t]:e.getAttribute(t))})}function l(t,n){if(s.has(t))return R(t),!1;null==(n=t.startsWith("on")?n:c(n)?n.call(r):n)||o.has(t)||t.startsWith("on")?null!=n&&o.has(t)?e[t]=n:t.startsWith("on")&&(u(t)?(c(n)||g(`\n                    \n                    The value of "${t}" must be a function.\n\n                    `),e[t]=function(e){n.call(r,e)}):g(`\n                \n                "${t}" doesn't seem to be a valid dom event.\n                \n                `)):e.setAttribute(t,n)}for(const[e,t]of Object.entries(r))l(e,t),a(e);return Object.defineProperties(r,{setAttrs:{set(e){n(e)||g("\n                    \n                    The value of [Attributes manager].setAttrs\n                    must be an object.\n                    \n                    ");for(const[n,r]of Object.entries(e))n in this?s.has(n)?R(n):this[n]=r:j(`\n                        \n                         The attributes manager "${t}" \n                         does not manage an attribute named "${n}",\n                         all the attributes must be defined in the attrsManager manager\n                         object.\n                        \n                        `)},enumerable:!1},[Symbol.toStringTag]:{value:()=>"Manager"}}),{[t]:r}}function _(e,t){T(`\n\t  "${t}" is an invalid value for the "${e}" property in the\n\t  "styles" object(template function).\n\t  `)}function L(e,t,n){let{tag:r,text:o,renderIf:i,attrs:l={},events:f={},styles:m={},children:v=[]}=e;if(r=c(r)?r():r,o=c(o)?o():o,s(i)&&!t)return T("\n              \n              You can not conditionally render a container in template\n              function.\n              \n              "),!1;p(r)||g(`\n                \n                "${y(r)}" is an invalid tag name, in template function.\n                \n                `),b(f)&&b(m)||g('\n                \n                The "events" and "styles" options in template function must be both plain Javascript objects.               \n                ');const w=document.createElement(r);if(w.template=Object.assign(e,{target:w,tag:r,text:o}),t&&(w.index=n),Object.entries(l).forEach((e=>{let[t,n]=e;const r=e=>{s(e)&&!a(e)&&(new Set(["value","currentTime"]).has(t)?w[t]=e:w.setAttribute(t,e)),w.template.attrs[t]=e};c(n)?(n=n(),r(n)):r(n)})),Object.entries(f).forEach((e=>{const[t,n]=e;u(t)?c(n)?w[t]=n:j(`\n\t\t  The "${t}" event was not created, because its handler\n\t\t  is not a function.\n\t\t  \n\t\t  You defined "${n}" as the value \n\t\t  of the "${t}" event.\n\t\t  `):T(`\n                        \n                        "${t}" doesn't seem to be a valid dom event.\n                        \n                        `)})),Object.entries(m).forEach((e=>{const[t,n]=e;if(d(t)){let e=c(n)?n():n;s(e)&&(w.style[t]=e),w.style[t]!==e&&s(e)&&_(t,e),w.template.styles[t]=e}else T(`\n                    \n                    "${t}" doesn't seem to be a valid style name.\n\n                    `)})),s(o)&&0==v.length){const e=h(o);s(e)&&w.appendChild(e)}else s(o)&&v.length>0?(j("\n                    \n                    It was found an element with both the text property and children property,\n                    and in this case Inter ignores the text property.\n                    \n                    "),B(w,v)):v.length>0&&B(w,v);return w}function B(e,t){let n=-1;for(const r of t){let{tag:t,text:o,attrs:i={},events:l={},styles:f={},children:m=[],renderIf:y}=r;if(n++,r.index=n,t=c(t)?t():t,o=c(o)?o():o,s(y)&&O(y)&&a(y))continue;s(y)&&!O(y)&&j("\n            \n            The value of the renderIf property must be only boolean(true/false), in template \n            function.\n            \n            "),p(t)||g(`\n            \n            "${t}" is an invalid tag name, in template function.\n            \n            `),b(l)&&b(f)||g('\n            \n            The "events" and "styles" options in template function must be both plain Javascript objects.               \n            ');const v=document.createElement(t);if(v.index=n,v.template=Object.assign(r,{target:v,tag:t,text:o}),Object.entries(i).forEach((e=>{let[t,n]=e;const r=e=>{s(e)&&!a(e)&&(new Set(["value","currentTime"]).has(t)?v[t]=e:v.setAttribute(t,e))};c(n)?(n=n(),r(n)):r(n),v.template.attrs[t]=n})),Object.entries(l).forEach((e=>{const[t,n]=e;u(t)?c(n)?v[t]=n:j(`\n\t\t  The "${t}" event was not created, because its handler\n\t\t  is not a function.\n\t\t  \n\t\t  You defined "${n}" as the value \n\t\t  of the "${t}" event.\n\t\t  `):T(`\n                    \n                    "${t}" doesn't seem to be a valid dom event.\n                    \n                    `)})),Object.entries(f).forEach((e=>{const[t,n]=e;if(d(t)){let e=c(n)?n():n;s(e)&&(v.style[t]=e),v.style[t]!==e&&s(e)&&_(t,e),v.template.styles[t]=e}else T(`\n                \n                "${t}" doesn't seem to be a valid style name.\n\n                `)})),s(o)&&0==m.length){const e=c(o)?h(o()):h(o);s(e)&&v.appendChild(e)}else s(o)&&m.length>0?(j("\n                \n                It was found an element with both the text property and children property,\n                and in this case Inter ignores the text property.\n                \n                "),B(v,m)):m.length>0&&B(v,m);e.appendChild(v)}}function J(e,i){n(e)?function(e,r){const o=Symbol.for("reactive"),s=new Set(["setProps","defineProps","deleteProps"]),i=Object.assign(Object.create(null),e);if(o in e)return!1;if(t(e))return j("\n        \n        Inter fails to define reactivity\n        in a plain Javascript object because it is a no-configurable object.\n        \n        "),!1;for(const t of Object.keys(e))s.has(t)&&(delete e[t],j(`\n        \n        "${t}" is a reserved property,\n        do not create a property with this name in the reactor\n        of reactive listing.\n        \n        `)),Object.defineProperty(e,t,{set(e){i[t]=e,r(),J(e,r)},get:()=>i[t],configurable:!0}),J(e[t],r);Object.defineProperties(e,{defineProps:{set(e){n(e)||g(`\n                    \n                    The value of the [List reactor => Object.defineProps] must be\n                    only a plain Javascript object, and you\n                    defined "${y(e)}" as its value.\n                    \n                    `);for(const[t,n]of Object.entries(e))t in this||"defineProps"===t||"setProps"===t||"dleteProps"===t||(i[t]=n,Object.defineProperty(this,t,{set(e){i[t]=e,r(),J(e,r)},get:()=>i[t],configurable:!0}),J(n,r));r()},enumerable:!1},setProps:{set(e){n(e)||g(`\n                    \n                    The value of the [list Reactor => object.setProps] must be\n                    a plain Javascript object, and you\n                    defined ${y(e)} as its value.\n                    \n                    `);for(const[t,n]of Object.entries(e))t in this&&"defineProps"!==t&&"setProps"!==t&&"deleteProps"!==t&&(i[t]=n,J(n,r));r()},enumerable:!1},deleteProps:{set(e){A(e)||g(`\n                    \n                    The value of the [List reactor => Object.deleteprops] must be \n                    an array, and you defined "${y(e)}" as its value.\n                    \n                    `);for(const t of e)t in this&&(delete this[t],delete i[t]);r()},enumerable:!1},[o]:{get:()=>!0}})}(e,i):A(e)?function(e,t){const n=Symbol.for("reactive");if(n in e)return!1;const r=["push","unshift","pop","shift","splice","sort","reverse"];for(const n of r)Object.defineProperty(e,n,{value(e,r,...o){if(Array.prototype[n].apply(this,arguments),t(),"push"===n||"unshift"===n)for(const e of arguments)J(e,t);else if("splice"===n&&s(o))for(const e of o)J(e,t)}});(function(e,t){for(const n of e)J(n,t)})(e,t),Object.defineProperty(e,n,{value:!0})}(e,i):o(e)?W(e,i):r(e)&&Y(e,i)}function M(e,t,o){n(e)?function(e,t,n){Object.keys(e).some(((e,r)=>{e==t&&z(n,r)}))}(e,t,o):r(e)?function(e,t,n){Array.from(e).some(((e,r)=>{e==t&&z(n,r)}))}(e,t,o):function(e,t,n){let r=-1;e.forEach(((e,o)=>{r++,o==t&&z(n,r)}))}(e,t,o)}function z(e,t){const n=e.children[t];l(n)&&e.removeChild(n)}function W(e,t,n,r){const o=Symbol.for("reactive");if(o in e)return!1;const s=["set","delete","clear"];for(const o of s)Object.defineProperty(e,o,{value(){if("delete"==o&&n&&M(this,arguments[0],r),Map.prototype[o].apply(this,arguments),t(),"set"==o){J(arguments[1],t)}}});!function(e,t){e.forEach((e=>{J(e,t)}))}(e,t),Object.defineProperty(e,o,{value:!0})}function Y(e,t,n,r){const o=Symbol.for("reactive");if(o in e)return!1;const s=["add","clear","delete"];for(const o of s)Object.defineProperty(e,o,{value(){"delete"==o&&n&&M(this,arguments[0],r),Set.prototype[o].apply(this,arguments),t(),"add"===o&&J(arguments[0],t)}});!function(e,t){e.forEach((e=>{J(e,t)}))}(e,t),Object.defineProperty(e,o,{value:!0})}const q=Symbol.for("reactive");function H(e){return"function"==typeof e&&(e=e()),e}function D(e,t){Object.assign(e,t)}function F(e,t){return e.length>t.length?e:t}function U(e,t,n){function r(t){e.hasAttribute(t)?e.removeAttribute(t):N.has(t)&&(e[t]=""),"checked"==t&&e.checked&&(e.checked=!1)}const o=Object.keys(t),i=Object.keys(n),c=F(o,i);for(let l=0;c.length>l;l++){const c=o[l],f=i[l],u=H(t[c]),d=H(n[f]);c in n?!s(d)||a(d)?r(f):s(d)&&!a(d)&&d!==u&&(N.has(f)?e[f]=d:e.setAttribute(f,d),"checked"!=f||e.checked||(e.checked=!0)):r(c),t[c]=d}}function X(e,t,n){const r=Object.keys(t),o=Object.keys(n),i=F(r,o);for(let a=0;i.length>a;a++){const i=r[a],c=o[a],l=H(t[i]),f=H(n[c]);if(i in n&&s(f))s(f)&&f!==l&&(d(c)?(e.style[c]=f,e.style[c]!==f&&_(c,f)):T(`\n        \n        "${c}" doesn't seem to be a valid style name.\n        \n        `));else{const t=e.style[i],n=e.getAttribute("style");s(t)&&0!==t.trim().length&&(e.style[i]=null),n&&0==n.trim().length&&e.removeAttribute("style")}t[i]=f}}function G(e,t,n){const r=Object.keys(t),o=Object.keys(n),i=F(r,o);for(let t=0;i.length>t;t++){const i=r[t],a=o[t];i in n&&s(n[i])||(e[i]=void 0),c(n[a])||!u(a)?s(n[a])&&(u(a)?e[a]=n[a]:T(`\n        \n        "${a}" doesn't seem to be a valid dom event.\n        \n        `)):(e[i]=void 0,j(`\n\t\t  The "${a}" event was not created, because its handler\n\t\t  is not a function.\n\t\t  \n\t\t  You defined "${n[a]}" as the value \n\t\t  of the "${a}" event.\n\t\t  `))}}function K(e,t,n){for(let r=0;r<e.children.length;r++){const o=e.children[r];if(o.index>t){e.insertBefore(n,o);break}}}function Q(e,t,n){const r=Array.from(e),o=Array.from(t);for(let e=0;e<r.length;e++){const t=r[e],s=o[e];let c=!1;const{children:l=[],events:f={},attrs:u={},styles:d={},renderIf:h}=t,{children:p=[],events:b={},attrs:m={},styles:y={},target:g,index:v}=s;let w;const j=H(t.text),T=H(s.text),A=H(t.tag),O=H(s.tag);if(n&&(w=n.children[n.children.length-1]),l.length===p.length)if(A===O){if(a(h)&&g&&null!=g.parentNode&&n.removeChild(g),i(h)){if(g&&null==g.parentNode){const e=L(t,!0,v);Object.assign(s,t),s.target=e,w&&w.index>v?K(n,v,e):n.appendChild(e);continue}if(!g)if(w&&w.index>v){const e=L(t,!0,v);Object.assign(s,t),s.target=e,K(n,v,e)}else{const e=L(t,!0,v);Object.assign(s,t),s.target=e,n.appendChild(e)}}l.length==p.length&&0!==l.length&&(c=!0,Q(l,p,g)),T!==j&&g&&!c&&(g.textContent=j,s.text=j),s.tag=A,g&&(U(g,m,u),X(g,y,d),G(g,b,f))}else{const e=L(t,!0,v);Object.assign(s,t),g&&null!=g.parentNode&&(n.replaceChild(e,g),s.target=e)}else if(g&&null!=g.parentNode){const e=L(t,!0,v);n.replaceChild(e,g),Object.assign(s,t),s.target=e}}}function V(e,t,n,r,o){e.open(t,n,!0,r,o)}function Z(){void 0===new.target&&w("Backend is a constructor, call it with the new keyword.")}Z.prototype={get[Symbol.toStringTag](){return"Ajax"},request(e){n(e)||g(`\n        \n        The argument of [Backend instance].request method\n        must be only an object, and you defined "${y(e)}"\n        as its argument.\n        \n        `);const{type:t,path:r,events:o={},timeout:i,withCredentials:a,body:l=null,headers:f={},security:u}=e;s(t)&&"string"==typeof t||g('\n        \n        You must define the type(method) of request, in Ajax with the "type" option and\n        it must be a string.\n        \n        '),s(r)&&"string"==typeof r||g('\n        \n        You must define the path where the request will be sent, with the "path" option and \n        it must be a string.\n        \n        ');const d=new Map;let h=!1;function p(){const e=new XMLHttpRequest,c=t.toUpperCase(),p=new Set(["onprogress","ontimeout","onabort"]),b={get status(){return e.status},get statusText(){return e.statusText},get headers(){return e.getAllResponseHeaders()},get data(){return function(e){if(void 0!==e)try{return JSON.parse(e)}catch(t){return e}}(e.responseText)},get[Symbol.toStringTag](){return"AjaxResponse"},isObj(){try{return n(JSON.parse(e.responseText))}catch(e){return!1}}};n(u)&&Object.keys(u).length>=2&&(u.username&&u.password?(V(e,c,r,u.username,u.password),h=!0):j('\n               \n                Invalid "security" object, security object must have the username and passoword \n                properties.\n                \n                ')),h||(V(e,c,r),h=!0),n(f)||g(`\n           \n           the "headers" property must be an object, and\n           you defined it as : ${y(f)}.\n           \n           `),Object.entries(f).forEach((([t,n])=>{e.setRequestHeader(t,n)})),Object.entries(o).forEach((([t,n])=>{p.has(t)?"onprogress"!==t?e[t]=()=>{n()}:e.onprogress=t=>{const r={abort:()=>e.abort(),progress:100*t.loaded/t.total};n(r)}:j(`\n            \n            There's not any event named "${t}" in Ajax request.\n            \n            `)})),e.onreadystatechange=function(){4==this.readyState&&(200==this.status?d.has("okay")&&d.get("okay")(b):d.has("error")&&d.get("error")(b))},"boolean"==typeof a&&(e.withCredentials=a),"number"==typeof i&&(e.timeout=i);e.send(s(l)?l instanceof FormData||"string"==typeof l?l:JSON.stringify(l):null)}const b={okay(e){c(e)||g(`\n                \n                The argument of okay method must be a function\n                and you defined ${y(e)} as its argument\n                \n                `),d.set("okay",e),p()},error(e){c(e)||g(`\n                \n                The argument of error method must be a function, and you\n                defined ${y(e)} as its argument.\n                \n                `),d.set("error",e),p()},response(e,t){arguments.length<2&&g(`\n                \n                The response method must have two arguments and you only\n                defined ${arguments.length}.\n                \n                `),c(e)||c(t)||g("\n                \n                The two arguments of response method must be functions.\n                \n                \n                "),d.set("okay",e),d.set("error",t),p()}};return b}},Object.freeze(Z.prototype),window.Ref=function(e){if(null!=new.target)g("\n        \n        Do not call the Ref function with the new keyword.\n\n        ");else{if(n(e)){const{in:t,data:r}=e;"string"!=typeof t&&g('\n                The value of the "in" property in the Ref function must be a string.\n                \n                '),n(r)||g('\n                The value of the "data" property in the Ref funtion must be a plain Javascript object.\n                \n                ');const o=new Set(["setRefs","observe"]);for(const e in r)o.has(e)?C(e):c(r[e])&&(r[e]=r[e].call(r));const i=Object.assign({},r),a={attrs:new Set,text:new Set,specialAttrs:new Set,observed:new Map,refs:i,add(e,t){t?(this.attrs.add(e),!this.refs&&e.refs&&(this.refs=e.refs)):(this.text.add(e),!this.refs&&e.refs&&(this.refs=e.refs))},updateSpecialAttrs(){for(let e of Array.from(this.specialAttrs)){e.target.hasAttribute("value")?e.target.removeAttribute("value"):e.target.hasAttribute("currentTime")&&e.target.removeAttribute("currentTime");const t=Object.entries(e.attr)[0],n=S(t[1]);for(let r of n){const n=new RegExp(`{\\s*(:?${r})\\s*}`,"g");e.target[t[0]]=t[1].replace(n,this.refs[r])}}},update2(){for(const e of Array.from(this.attrs)){let{target:t,attrs:n}=e;for(let[e,r]of Object.entries(n)){const n=S(r);for(let e of n)if(e in this.refs){const t=new RegExp(`{\\s*(:?${e})\\s*}`,"g");r=r.replace(t,this.refs[e])}t.getAttribute(e)!==r&&t.setAttribute(e,r)}}},update(){if(this.text.size>0)for(const e of Array.from(this.text)){let{target:t,text:n}=e;const r=S(n);for(const e of r)if(e in this.refs){const t=new RegExp(`{\\s*(:?${e})\\s*}`,"g");s(n)&&(n=n.replace(t,this.refs[e]))}s(n)&&t.textContent!==n&&(t.textContent=n)}this.attrs.size>0&&this.update2(),this.specialAttrs.size>0&&this.updateSpecialAttrs()}};k(m(t),i,a);const l=new Proxy(i,{set(e,n,r,o){const s=e[n];if(c(r)?(r=r.call(o),Reflect.set(e,n,r,o)):Reflect.set(e,n,r,o),1==a.observed.size){a.observed.get("callBack")(n,r,s)}if(a.specialAttrs.has(n)&&a.updateSpecialAttrs(),n in e)return a.update(),!0;k(m(t),i,a)},get:(...e)=>Reflect.get(...e)});return Object.defineProperties(l,{setRefs:{set(e){if(n(e)){const t=new Set(["setRefs","observe"]);for(const[n,o]of Object.entries(e)){if(t.has(n)){C(n);continue}const e=r[n];if(c(o)?i[n]=o.call(l):i[n]=o,1==a.observed.size){a.observed.get("callBack")(n,o,e)}}a.update()}},enumerable:!1},observe:{value:e=>(c(e)||g("\n                        \n                        The argument of [Reference reactor].observe() must be a function.\n                        \n                        \n                        "),0===a.observed.size&&(a.observed.set("callBack",e),!0)),writable:!1,enumerable:!1}}),l}g('\n            \n            The argument of the "Ref" must be a plain object.\n\n            ')}},window.renderIf=function(e){if(n(e)||g("\n        \n        The argument of renderIf must be a  plain Javascript object.\n        \n        "),void 0===new.target){const{in:t,data:r}=e;"string"!=typeof t&&g('\n             The value of the "in" property in renderIf function must be a string.\n            \n            '),n(r)||g('\n            The value of the "data" property in renderIf function must be a plain Javascript object.\n\n            ');const o=new Set(["setConds","observe"]),s=m(t),l=new Set;for(let[e,t]of Object.entries(r))o.has(e)?E(e):(t=c(t)?t.call(r):t,O(t)||w(`\n                \n                The value of a conditional property must be boolean(true/false),\n                and the value of  "${e}" property is not boolean.\n                \n                `),r[e]=t);!function e(t){let n=-1;const o=t.childNodes;for(const s of o){n++;const o={target:s,if:void 0,else:void 0,ifNot:void 0,i:n,root:t};if(s.index=n,3==s.nodeType)continue;const i=s.nextElementSibling,a=s.previousElementSibling;if(s.children.length>0&&e(s),s.hasAttribute("_ifNot"))(s.hasAttribute("_if")||s.hasAttribute("_else"))&&T("\n                    The parser found an element with the _ifNot attribute and one more conditional attribute,\n                    it's forbidden.\n                    \n                    "),o.ifNot=s.getAttribute("_ifNot"),o.ifNot in r?(s.removeAttribute("_ifNot"),l.add(o)):T(`\n                    \n                    The conditional rendering parser found\n                    an element with the _ifNot attribute and the value\n                    of this attribute is not a conditional property in the data object.\n\n                    {\n                        element: ${s.nodeName.toLowerCase()},\n                        _ifNot: ${o.ifNot},\n                        data: ${Object.keys(r)}\n                    }\n                    \n                    `);else if(s.hasAttribute("_else")&&(!a||!a.if))return T('\n                                \n                The parser found an element with the "_else" attribute,\n                but there is not an element with the "_if" attribute before it.\n\n                '),!1;if(s.hasAttribute("_if")){if(s.hasAttribute("_else"))return T('\n                    \n                    The parser found an element which has simultaneously\n                    the "_if" and "_else" attribute. It\'s forbidden.\n                    \n                    '),!1;o.if=s.getAttribute("_if"),s.removeAttribute("_if"),s.if=!0,o.if in r||(T(`\n                    \n                    The conditional rendering parser found\n                    an element with the _if attribute and the value\n                    of this attribute is not a conditional property in the data object.\n\n                    {\n                        element: ${s.nodeName.toLowerCase()},\n                        _if: ${o.if},\n                        data: ${Object.keys(r)}\n                    }\n                    \n                    `),o.if=void 0)}if(o.if&&i&&i.hasAttribute("_else")){if(i.hasAttribute("_if"))return T('\n                    \n                    The parser found an element which has simultaneously\n                    the "_if" and "_else" attribute. It\'s forbidden.\n                    \n                    '),!1;o.else=i,i.removeAttribute("_else")}o.if&&l.add(o)}}(s);const u=function(e,t){const r=Array.from(e);function o(e){for(const t of r){const{target:n,if:r,else:o,ifNot:c,i:l,root:u}=t,d=P(u)[l];c?a(e[c])&&!n.isSameNode(d)?f(d)||0!==u.textContent.trim().length?s(u,n):u.appendChild(n):n.parentNode==u&&i(e[c])&&u.removeChild(n):a(e[r])?n.parentNode!=u||o?o&&n.parentNode==u&&(u.removeChild(n),s(u,o)):u.removeChild(n):d&&d.isSameNode(n)?o&&null!=o.parentNode&&u.removeChild(o):o&&null!=o.parentNode?(u.removeChild(o),s(u,n)):s(u,n)}}function s(e,t){const n=P(e),r=n[n.length-1];if(null==t.parentNode)if(r&&r.index>t.index){for(const r of n)if(r.index>t.index){e.insertBefore(t,r);break}}else e.appendChild(t)}const l=new Set(["setConds","observe"]),u=new Map,d=Object.assign({},t);o(d);const h=new Proxy(d,{set(e,n,r){if(!(n in t)&&!l.has(n))return j(`\n            The "${n}" property was not defined \n            as a conditional property.\n            \n            `),!1;if(!O(r)&&!l.has(n))return w(`\n                \n            The value of a conditional property must be boolean(true/false),\n            and the value of  "${n}" property is not boolean.\n            \n            `),!1;if(Reflect.set(e,n,r),!l.has(n)&&(o(d),1==u.size)){u.get("callBack")(n,r)}return!0},deleteProperty:(...e)=>!1});return Object.defineProperties(h,{observe:{value:e=>(c(e)||g("\n            The argument of [renderIf reactor].observe()\n            must be a function.\n            "),0==u.size&&(u.set("callBack",e),!0)),writable:!1,enumerable:!1},setConds:{set(e){n(e)||g(`\n                \n                The value of [renderIf reactor].setConds must be\n                a Javascript object, and you defined ${y(e)}\n                as its value.\n\n                `);for(let[n,r]of Object.entries(e))l.has(n)?E(n):(r=c(r)?r.call(t):r,O(r)||w(`\n                \n                The value of a conditional property must be boolean(true/false),\n                and the value of  "${n}" property is not boolean.\n                \n                `),n in this||j(`\n                    \n                    "${n}" was not defined as conditional property.\n                    \n                    `),d[n]=r);o(d)},enumerable:!1}}),h}(l,r);return u}g("\n        \n        renderIf is not a constructor, do not call it with\n        the new keyword.\n        \n        ")},window.toAttrs=function(e){void 0!==new.target&&g('\n        toAttrs is not a constructor,\n        do not call it with the "new" keyword.\n        \n        '),n(e)||g('\n        The argument of "toAttrs()" function must be an object.\n        ');const{in:t,data:r}=e;return"string"!=typeof t&&g('\n    \n    The "in" property value in toAttrs() function must be a string.\n    \n    '),n(r)||g('\n\n    The "data" property value in toAttrs() function must be an object.\n  \n    '),function(e,t){const n=Object.getOwnPropertyNames(t),r=e.getElementsByTagName("*"),o=Object.create(null);for(const e of r)if(1==e.attributes.length){const r=e.attributes[0].name;for(const s of n){if(new RegExp(`{...${s}}`).test(r)){e.removeAttribute(r);const n=I(e,s,t[s]);o[Object.keys(n)[0]]=Object.values(n)[0]}else{const e=/{(:?\.){3}(:?[\s\S]+)}/.test(r),n=/{(:?\.){4,}(:?[\s\S]+)}/.test(r),o=r.replace(/{(:?\.){3}/,"").replace("}","");n&&T(`\n                \n                "${r}" is an invalid syntax for attributes manager.\n                The attributes manager must have only three dots.\n\n                Ex: {...managername}\n                \n                `),e&&!t.hasOwnProperty(o)&&T(`\n            \n            The attributes manager parser found a manager named "${o}" but\n            you did not define it in the toAttrs function.\n            \n            `)}}}return o}(m(t),r)},window.renderList=function(i){void 0!==new.target&&g('\n        \n        renderList is not a constructor, do not call\n        it with the "new" keyword.\n        \n        '),n(i)||g("\n        \n        The options(the argument of renderList) must be a plain Javascript object.\n        \n        ");let{in:a,each:f,do:u}=i;const d=m(a);(function(e){return"string"==typeof e})(a)||g('\n        \n        The "in" option in renderList must be a string.\n        \n        '),x(f)||g(`\n  \n        "${y(f)}" is not a valid value for the "each" option in renderList.\n        The value that are accepted in "each" option, are:\n\n        Array.\n        Plain js object.\n        Map.\n        Set.\n\n         \n        `),c(u)||g('\n        \n        The value of the "do" option in renderList, must be only a function.\n        \n        ');let h,p=!0;function b(){A(f)?(h=function(e,n){t(e)&&w("\n        \n        Inter fails to define the reactivity in the list reactor,\n        because the array  of the each option is not configurable.\n        \n        ");const r=new Set(["otherArray","addItems"]);return new Proxy(e,{set:(e,t,o)=>r.has(t)?(Reflect.set(e,t,o),!0):(Reflect.set(e,t,o),n(),"number"!=typeof t&&x(o)&&J(o,n),!0),get:(e,t)=>e[t]})}(f,T),function(n,r,o,s,i){if(t(n))return!1;if(q in n)return!1;function a(){g('\n                \n        You are not returning the template function\n        in the "do" method, renderList, you must return\n        the template function.\n        \n        ')}Object.defineProperties(n,{shift:{value(){const e=Array.prototype.shift.apply(n,void 0),t=r.children[0];return t&&(r.removeChild(t),o()),e}},pop:{value(){const e=Array.prototype.pop.apply(n,arguments),t=r.children,s=t[t.length-1];return s&&(r.removeChild(s),o()),e}},push:{value(){const t=Array.prototype.push.apply(n,arguments);function c(t,n){const c=s.call(i,t,n,i);e(c)||a(),r.appendChild(L(c.element)),J(t,o)}if(1==arguments.length)c(...arguments,n.length-1);else if(arguments.length>1)for(const e of arguments)c(e,n.length-1);return o(),t}},unshift:{value(){const t=Array.prototype.unshift.apply(n,arguments);if(arguments.length>1){let t=arguments.length-1;for(;t>-1;t--){const n=s.call(i,arguments[t],t,i);e(n)||a(),r.children[0]?r.insertBefore(L(n.element),r.children[0]):r.appendChild(L(n.element)),J(arguments[t],o)}}else if(1==arguments.length){const t=s.call(i,arguments[0],0,i);e(t)||a(),r.children[0]?r.insertBefore(L(t.element),r.children[0]):r.appendChild(L(t.element)),J(arguments[0],o)}return o(),t}},splice:{value(t,c,...l){const f=Array.prototype.splice.apply(n,arguments);if(0==l.length){let e=t;const n=c;for(let t=0;t<n;t++){const t=r.children[e];t&&r.removeChild(t)}}else if(0==c&&l)for(let n=l.length-1;n>-1;n--){const c=s.call(i,l[n],n,i);J(l[n],o),e(c)||a(),r.children[t]?r.insertBefore(L(c.element),r.children[t]):r.appendChild(L(c.element))}return o(),f}},[q]:{value:!0}})}(f,d,T,u,h)):n(f)?h=function(e,n,r){return t(e)&&w("\n        \n        Inter fails to define the reactivity in the list reactor,\n        because the array  of the each option is not configurable.\n        \n        "),new Proxy(e,{set:(e,t,r)=>(Reflect.set(e,t,r),n(),"number"!=typeof t&&x(r)&&J(r,n),!0),get(){return Reflect.get(...arguments)},deleteProperty(e,t){if(t in e)return M(e,t,r),Reflect.deleteProperty(...arguments),n(),!0;j(`\n            You are trying to delete the "${t}" property in the list\n            reactor, but that property does not exist in the list reactor.\n            \n            `)}})}(f,T,d):r(f)?(Y(f,T,!0,d),h=f):o(f)&&(W(f,T,!0,d),h=f)}function v(){if(Symbol.for("reactive")in f)return!1;Object.defineProperties(f,{otherArray:{set(e){A(e)||g("The value of [List reactor].otherArray property must be an Array."),f=e,v(),b(),T();for(const t of e)J(t,T)},configurable:!0,enumerable:!1},addItems:{value(e,t){if(s(t)&&"number"!=typeof t&&g("\n                        \n                        The second argument of [LIST REACTOR].addItems must \n                        be a number.\n                        \n                        "),A(e)||g("\n                        \n                        The first argument of [LIST REACTOR ].addItems must be an Array.\n                        \n                        "),!s(t)||t>this.length-1)for(const t of e)this.push(t);else if(0==t||t<0)for(let t=e.length-1;t>-1;t--)this.unshift(e[t]);else for(let n=e.length-1;n>-1;n--)this.splice(t,0,e[n])},configurable:!0,enumerable:!1,writable:!1}})}function T(){const t=new $(f);!function(e,t){if(e.children.length>t.source.values.length){let n=e.children.length-t.source.values.length;for(;n--;)e.removeChild(e.children[n])}}(d,t),t.each(((t,n,r)=>{let o;if(o="array"===r?u.call(h,t,n,h):"object"===r?u.call(h,t[0],t[1],h):"number"===r?u(t):u.call(h,t,h),e(o)){const e=d.children[n];l(e)?e.template?function(e,t,n){const r={children:!0};(function(e,t,n){const{attrs:r={},events:o={},styles:i={},children:a}=e,{attrs:c={},events:l={},styles:f={},children:u,target:d}=t,h=d.parentNode,p=H(e.text),b=H(t.text),m=H(e.tag),y=H(t.tag);if(m!==y){const r=L(e);return h.replaceChild(r,d),n.children=!1,D(t,e),t.target=r,!0}if(g=a,v=u,A(g)&&!A(v)||!A(g)&&A(v)){const r=L(e);return h.replaceChild(r,d),n.children=!1,D(t,e),t.target=r,!0}var g,v;if(function(e,t){return A(e)&&A(t)}(a,u)&&a.length!==u.length){const r=L(e);return h.replaceChild(r,d),n.children=!1,D(t,e),t.target=r,!0}s(a)||s(u)||p!==b&&(d.textContent=p,t.text=p);U(d,c,r),G(d,l,o),X(d,f,i)})(e,t,r),r.children&&e.children&&e.children.length>0&&Q(e.children,t.children,n)}(o.element,e.template,e):(j("\n                    \n                    Avoid manipulating what Inter manipulates.\n                    \n                    "),d.replaceChild(L(o.element),e)):d.appendChild(L(o.element)),p&&J("object"!==r?t:t[1],T)}else g('\n            \n           The template function is not being returned inside the "do" method in\n           renderList(reactive listing), just return the template function.\n            \n            ')}))}return A(f)&&v(),b(),T(),p=!1,h},window.template=function(e){if(n(e)){return{[Symbol.for("template")]:!0,element:e}}g(`\n    \n    The argument of the template function must be a plain Javascript object,\n    but you defined "${y(e)}" as its argument.\n    \n    `)},window.Backend=Z,console.log("The global version 2.0.16 of Inter was successfully loaded.")}();