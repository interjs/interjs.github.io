
(function(){
    
/**
 * Interjs 
 * MIT LICENSED BY - Denis Power
 * Repo - https://github.com/interjs/inter
 * 2021-2022
 * GENERATED BY INTER GLOBAL BUILDER
 * 
 * 
 * 
 */

 
// Helpers functions.

 function isValidTemplateReturn(arg){

    return isObj(arg) && arg.element && arg[Symbol.for("template")]
        
        
}

 function isNotConfigurable(obj){

    return (Object.isFrozen(obj) || Object.isSealed(obj)
    || !Object.isExtensible(obj)
    )


}

 function isObj(o){ 

    // For plain objects.    
    
      return (Object.prototype.toString.apply(o, void 0)
      =="[object Object]"
      )
    
     }
     
  function isSet(o){

    return o instanceof Set;

 }

  function isMap(o){

    return o instanceof Map;

 }

  function isDefined(t){
    
        return t!=void 0;
    
    
     }
    
     /**
      * Indirect boolean value checking can cause
      * unexpected result, that's why I am using direct 
      * checking here.
      * 
      */

  function isTrue(v){
    
        return Object.is(v,true);
    
     }
    
  function isFalse(v){
    
        return Object.is(v,false);
    
     }
    
 /*</>*/   

  function isCallable(fn){
    
        return typeof fn=="function";
    
     }
    



  function isAtag(tag){


        return tag instanceof HTMLElement;


     }
 
 function isANode(target){

    return isDefined(target) && (target.nodeType==1 || target.nodeType==3)

}



   function validDomEvent(eventName){

    return eventName in HTMLElement.prototype;


 }

  function validStyleName(styeName){

    return (styeName in document.createElement("p").style);

 }   

  function createText(text){


    return document.createTextNode(text);


 }

  function validTagOption(option){

    return typeof option=="string";


 }

  function validStylesOrEventsOptions(option){

    return isObj(option);

 }
 
 function getId(id){
    
        if(typeof id!=="string"){

            syErr(`
            
            The id's value must be an string.
            
            `)

        };

        const el=document.getElementById(id);
        
        if(el==void 0){
    
            syErr(`
            
            There's not an element in the document by id "${id}".
    
            `)
    
        }else{
    
            return el;
    
        }
    
     }
    
  function valueType(val){
    
         if(
            typeof val=="undefined" ||
            typeof val=="symbol" ||
            typeof val=="bigint" ||
            typeof val=="boolean" ||
            typeof val=="function" ||
            typeof val=="number" ||
            typeof val=="string"
        ){
    
    
            return typeof val;
    
        }else{
    
            /**
             * 
             * @val may be an array, a plain object or even
             * a native Javascript object,
             * let's check with the type() function.
             * 
             */
    
             return type(val)
    
    
        }
    
    
     }
    
    
    // WARNINGS HELPERS
    
 function syErr(err){
    
        throw new SyntaxError(`
        
        Inter syntaxError : ${err}
        
        `);
    
    }
    
 function err(e){
    
        throw new Error(`
        
        Inter error: ${e}
        
        `)
    
    }
    
 function consW(w){
    
        console.warn(`
        Inter warning: ${w}
        
        `);
    
    }
    
 function ParserWarning(w){
    
        console.error(`
    
       Inter parser error: ${w}
        
        `)
    
    }
    
    //
    
    
     function isArray(arg){

        return Array.isArray(arg);

    }
    
    
    
 function  type(val){
    
        // All Javascript objects.
    
         const isAnobject=(
            
            isDefined(val) &&
            
            Object.prototype.toString.call(val).startsWith("[object")
             
             );
    
    
             if(isAnobject){
    
    
              return ( Object.prototype.toString.call(val).replace("[object","")
              .replace("]","").replace(/\s/g,"").toLowerCase()
              
              );
    
    
             }else{
    
                /**
                 * @val is null.
                 * 
                 */
    
                 return "null";
    
    
             }
    
    
        }
    
    


     function isBool(val){

        /**
         * 
         * Not use typeof val==="boolean"; due to 1 and 0.
         * 
         */

        return val==true || val==false;

    }


    

    //Just for renderList.

     function validInProperty(IN){

        

        return typeof IN=="string" 

        


    }


     function validEachProperty(each){

        return (

            each instanceof Array ||  isObj(each) || each instanceof Map || each instanceof Set ||
            typeof each==="number"

        )


    }

    function toIterable(data){

        const iterable={
         values:new Array(),
         type:void 0,

        };

        if(isArray(data)){

           iterable.values=data;
           iterable.type="array"

        }else if(isObj(data)){

            iterable.values=Object.entries(data);
            iterable.type="object"

        }else if(data instanceof Map){

            data.forEach((value, key)=>{

                iterable.values.push([key, value]);

            });

            iterable.type="object"


        }else if(data instanceof Set){

         iterable.values=Array.from(data);
         iterable.type="set";
         

        }else if(typeof data==="number"){

            for(let i=0; i<data; i++){
                iterable.values.push(i);

            };

            iterable.type="number";



        };

        return iterable;

        

    }

     function Iterable(data){


      this.source=toIterable(data);
      
      

    }

    Iterable.prototype.each=function(callBack){

        let index=-1;

        for(const data of this.source.values){

            index++;

            callBack(data, index, this.source.type);

        };



    }

    //</>


function hasProp(object){

    return Object.keys(object).length>0;


}


function hasRefs(text){


    return /{\s*.*\s*}/.test(text);

}
 

 function getRefs(text){

    /**
     *
     * @text must be a string containing refs.
     * 
     * This function is used in reference computation,
     * it helps Inter making an eficient reference computation.
     * 
     */

     const ref=/{\s*(:?[\w-\s]+)\s*}/g;
     
     
     const refs=new Set();
        

        text.replace(ref, (plainRef)=>{
            
            const refName=plainRef.replace("{","").replace("}","").trim();
            
            refs.add(refName);


        })


     

         return Array.from(refs); 

     

}



/**
 * 
 * We are considering them as special attributes
 * because we must not use the settAttribute method
 * to set them.
 * 
 */

const specialAttrs=new Set([
        "currentTime", "value",
    ]);



function refParser(p,refs,name,rparse){


    
    /**
     *  There will be time
     *  that we can write something like this:
     * 
     *  <div>
     * 
     * <strong>Hi</strong>, { name }! Are you fine?
     * </div>
     * 
     * Usually the browser interprets space as a childNode,
     * in the above code, the div container has
     * two childNodes,a tag(strong) and a text.
     * 
     * 
     */

    
     function getTextNodes(el){

    
        

        let _childNodes=new Set();
    
        if(el.hasChildNodes())
        
        for(let child of el.childNodes){
    
            if(child.nodeType==3 && child.textContent.trim().length>0 && hasRefs(child.textContent)){
               
                _childNodes.add(child)
    
                 
            }
    
    
        }
    
        return Array.from(_childNodes);
    
        
     }
    
        const children=p.getElementsByTagName("*");
        
    
        function rChild(parentNode){
    
            
            function runRef(node){
    
                for(let r in refs){
    
                    const pattern=new RegExp(`{\\s*${r}\\s*}`)
                    
                    if(!node.ref &&  node.textContent.trim().length>0 &&
                     pattern.test(node.textContent)  
                    ){
                    
                       const register={
                           target:node,
                           text:node.textContent,
                           refs:refs,
       
                   };
    
                   node.ref=true;

                   rparse.add(register);
    

    
                }
    
            }
        }
            
             if(parentNode.nodeType==1){

            for(let node of parentNode.childNodes){
    
                if(node.hasChildNodes() && node.nodeType==1){
                  
                    rChild(node);
                    continue;
                     
                }
    
                runRef(node)
    
        }
        } else if(parentNode.nodeType==3){
    
              // Parsing the references
              // in the main container's 
              // text nodes.
    
              runRef(parentNode);
    
              
    
        }
    }
    
    if(getTextNodes(p).length>0){
    
        for(let text of getTextNodes(p)){
    
        rChild(text);
        
    
        }
    
    }
        
        for(const child of children){ 
    
            
            const _register={
                target:child,
                attrs:Object.create(null),
                refs:refs
            }
    
            for(const attr of child.attributes){
    
                 for(const r in refs){
                     const pattern=new RegExp(`{\\s*${r}\\s*}`)
                  if(pattern.test(attr.value)){
                
                    if(!specialAttrs.has(attr.name)){
    
                        
                    _register.attrs[attr.name]=attr.value;
                    
                    }else{
                      
                      rparse.specialAttrs.add({
                          target:child,
                          attr:{
                                [attr.name]:attr.value
                          }
                      })

                      
                        
                    }
                    
                    
                  }
    
                 

            }
            
            }
    
    
            if(hasProp(_register.attrs)){
    
                rparse.add(_register, true);
    
                // The true argument says to the parser
                // to register the reference as an attribute reference.
    
            }
    
            if(child.hasChildNodes()){
          
              const nodes=child.childNodes;
              
              for(const node of nodes){
    
                if(node.hasChildNodes()){
                   
                    rChild(node);
                    continue;
    
                
    
                }
    
                
    
                for(const r in refs){
    
                    const pattern=new RegExp(`{\\s*${r}\\s*}`)
                    
                 if(!node.ref && node.textContent.trim().length>0 &&
                  pattern.test(node.textContent)  
                 ){
                 
                    
                    const register={
                        target:node,
                        text:node.textContent,
                        refs:refs
    
                }
    
             node.ref=true;
      
              rparse.add(register)
                
            }
        }
    }
    
            }else{
    
                
    
            const text=child.textContent;
            
            const register={
                target:child,
                text:text,
                refs:refs
                
            };
            
            for(let r in refs){
    
                const pattern=new RegExp(`{\\s*${r}\\s*}`)
    
                if(!child.ref && pattern.test(text)){
    
                rparse.add(register);

                child.ref=true;
                    
                    
                    
    
                }
    
            }
           
           
          
    
        
    
    
}
    
    
    
    
    
    

}


    rparse.update()
    
}

    
    


 function Ref(obj){

    if(new.target!=void 0){

        syErr(`
        
        Do not call Ref with the new keyword.

        `)

    }else{

        if(!isObj(obj)){

            syErr(`
            
            The argument of Ref must be a plain object.

            `)

        }else{

            const{
                in:IN,
                data,
                
            }=obj;
            
            if(!(typeof IN==="string")){

                syErr(`
                The value of "in" property in the Ref function must be a string
                
                `)

            };

            if(!isObj(data)){

                syErr(`
                The value of "data" property in the Ref funtion must be a plain Javascript object.
                
                `)

            }

            

  
            
            
            for(const r in data){

                if(r=="setRefs" || r=="observe"){

                    consW(`
                    
                    "${r}" is a reserved property, you can use it
                    as the reference name.
                    
                    `);

                    continue;

                }

                if(isCallable(data[r])){

                    data[r]=data[r].call(data);

                }

            }

            const store={
                attrs: new Set(), // Attribute reference.
                text:new Set(), // Text reference.
                specialAttrs: new Set(),     
                observed:new Map(),          
                refs:void 0,
                add(setting,attr){
 
                    // if attr, the parser must register the reference 
                    // as an attribute reference.

                    if(attr){

                        this.attrs.add(setting)

                        if(!this.refs && setting.refs){

                            this.refs=setting.refs;

                        }

                    }else{

                        this.text.add(setting);
                        
                        if(!this.refs && setting.refs){

                            this.refs=setting.refs;
                        }

                    }
            
                     
                  },
                
                updateSpecialAttrs(){


                    for(let special of Array.from(this.specialAttrs)){

                        if(special.target.hasAttribute("value")){

                            special.target.removeAttribute("value");

                        }else{

                            if(special.target.hasAttribute("currentTime")){

                                special.target.removeAttribute("currentTime");

                            }

                        }
                     
                        const  sp=Object.entries(special.attr)[0];

                
                        
                        

                        const refs=getRefs(sp[1]);

                        

                        for(let ref of refs){

                            
                            const pattern=new RegExp(`{\s*${ref}\s*}`, "g");
                             
                            special.target[sp[0]]=sp[1].replace(pattern, this.refs[ref]);


                        }
                        
                        



                    }

                },
                update2(){
            
                    // This is the attribute reference updater.
            
                    for(const a_r of  Array.from(this.attrs)){
            
                        let{
                            target,
                            attrs,
                            
                        }=a_r;

               
            
                        for(let [name,v] of Object.entries(attrs)){
            
                            const refNames=getRefs(v);

                            
                            for(let refName of refNames){
            
                                if(refName in this.refs){
                                

                             
                                const pattern=new RegExp(`{\\\s\*\(\:\?${refName}\)\\\s\*}`,"g")
                
                                 v=v.replace(pattern,this.refs[refName]);
                            
                                  
                                 


                                }
                            }
                            
                            
                            
                  
                            if(target.getAttribute(name)!==v){
                            
                                target.setAttribute(name,v);

                            }
            
                            
            
                        }
            
                    

                    }
            
                },
                update(){
            
                    // This is the text reference updater.
            
                    if(this.text.size>0){
            
                        

                    for(const t_r of  Array.from(this.text)){
            
                        let {
                            target,
                            text,
                            
                            
                        }=t_r;

                        // Returns the ref's Names
                         // in the string "text".                  
                        const refNames=getRefs(text);


                    for(const refName of refNames){
            
                        
                        
                        if(refName in this.refs){
                      
                        const pattern=new RegExp(`{\\\s\*\(\:\?${refName}\)\\\s\*}`,"g")
                        
                       if(isDefined(text)){     
                        
                        text=text.replace(pattern, this.refs[refName]);
                      
                    
                     
                    
                        }
                    }

                    }
                        if(isDefined(text)){
                            
                      if(target.textContent!==text){

                        target.textContent=text;
                      }

                        }
            
                
            
            }
                
            }

            // After updating the text reference, let's update the
                // attribute reference.
                
                if(this.attrs.size>0){
            
                    this.update2();
            
                }

                if(this.specialAttrs.size>0){
                    
                    this.updateSpecialAttrs();

                }
            }
            }
            
            

            
            const proxyTarget=Object.assign({}, data);

            refParser(getId(IN),proxyTarget,IN, store);

            const reactor=new Proxy(proxyTarget,{

                set(t,k,v,p){

               const oldValue=t[k];     
               
                    if(isCallable(v)){

                        v=v.call(p);
                
                        Reflect.set(t,k,v,p);

                    }else{
      
                   Reflect.set(t,k,v,p);
                    
                }

                
                if(store.observed.size==1){

                    const callBack=store.observed.get("callBack");

                    callBack(k,v, oldValue);

                    }

                    

               if(store.specialAttrs.has(k)){

                store.updateSpecialAttrs();

               }
                
                   if(!(k in t)){
                    
                    // Dynamic ref.

                    refParser(getId(IN),proxyTarget, IN,store)



                   }else{
                   store.update();
                   return true;

                   }

                   

                },

                get(...args){

                    


                   return Reflect.get(...args);

                    

            }

            })

            

            Object.defineProperties(reactor, {

                setRefs:{

                set(o){

                    if(isObj(o)){

                        
                        for(const [refName,refValue] of Object.entries(o)){

                            if(refName=="observe" || refName=="setRefs"){

                                consW(`
                                
                                "${refName}" is a reserved property, you can not
                                use it as the reference name.
                                
                                `)

                                continue;

                            }

                            const oldRefValue=data[refName];
                            
                            if(isCallable(refValue)){

                            proxyTarget[refName]=refValue.call(reactor);

                            }else{
                           
                            proxyTarget[refName]=refValue;

                            }

                                
                            if(store.observed.size==1){

                                const callBack=store.observed.get("callBack");
            
                                callBack(refName, refValue, oldRefValue);
            
                                }

                        }

                        

                        store.update();

                    }

                }
            },
            observe:{

                value(callBack){

                    if(!isCallable(callBack)){


                        syErr(`
                        
                        The argument of [Reference reactor].observe() must be a function.
                        
                        
                        `)

                    };

                    if(store.observed.size===0){

                        store.observed.set("callBack", callBack);

                        return true;

                    }

                    return false;
                    



                }

            }

            });


            return reactor;

        


        
        }

    }

}


function getChildNodes(root){

    const nodes=new Array();

    root.childNodes.forEach((node)=>{
        
        if(node.nodeType==1 || node.nodeType==3 && !node.textContent.trim().length==0){

            nodes.push(node);

        }

    });

    return nodes;


}


 function renderIf(obj){


    if(!isObj(obj)){


        syErr(`
        
        The argument of renderIf must be a  plain Javascript object.
        
        `)

    }

    if(new.target!==void 0){

        syErr(`
        
        renderIf is not a constructor, do not call it with
        the new keyword.
        
        `)


    }else{

        const{
            in:IN,
            data,
            
        }=obj;

        if(!(typeof IN==="string")){

            syErr(`
            The value of "in" property in renderIf function must be a string.
            
            `)

        };

        if(!isObj(data)){

            syErr(`
            The value of "data" property in renderIf function must be a plain Javascript object.

            `)

        }

        if(("setConds" in data)){

            delete data.setConds;

            consW(`
            
            "setConds" is a reserved property in conditional rendering, you can not use it
            as conditional property that's why Inter deleted it from the data object.
            
            `)

        }

        
        const theContainer=getId(IN);
        const els=new Set();

function parseAttrs(container){

         let index=-1;

        for(const child of container.children){

            index++;

            const setting={
                target:child,
                if:void 0,
                else:void 0,
                ifNot:void 0,
                i:index,
                root:container
            }


           const sibling=child.nextElementSibling,
                 previous=child.previousElementSibling;

            
            if(child.children.length>0){

                parseAttrs(child)
                

            }

            if(child.hasAttribute("_ifNot")){
                
                
                if(child.hasAttribute("_if") && child.hasAttribute("_else")){

                    ParserWarning(`
                    The parser found an element with _ifNot attribute and one more conditional attribute,
                    it's forbidden.
                    
                    `)

                }

                setting.ifNot=child.getAttribute("_ifNot");

                if(setting.ifNot in data){

                    child.removeAttribute("_ifNot");

                    els.add(setting);

                }else{

                    
                    ParserWarning(`
                    
                    The conditional rendering parser found
                    an element with the _notIf attribute and the value
                    of this attribute is not a conditional property in data object.

                    {
                        element: ${child.nodeName.toLowerCase()},
                        _ifNot:${setting.ifNot},
                        data:${Object.keys(data)}
                    }
                    
                    `)
                }


            }

        else if(child.hasAttribute("_else") && !previous.hasAttribute("_if")){


                ParserWarning(`
                                
                The parser found an element with an "_else" attribute,
                but there is not an element by attribute "_if" before it.

                `)

                return false;

            };
            

             if(child.hasAttribute("_if")){
                
                if(child.hasAttribute("_else")){

                    ParserWarning(`
                    
                    The parser found an element which has simultaneousilly
                    the "_if" and "_else" attribute. It's forbidden.
                    
                    `)

                    return false;

                }

                setting.if=child.getAttribute("_if");
                child.removeAttribute("_if");

                if(!(setting.if in data)){

                    ParserWarning(`
                    
                    The conditional rendering parser found
                    an element with the _If attribute and the value
                    of this attribute is not a conditional property in data object.

                    {
                        element: ${child.nodeName.toLowerCase()},
                        _if:${setting.if},
                        data:${Object.keys(data)}
                    }
                    
                    `);

                    setting.if=void 0;

                }

                                
                

            }  if(setting.if && sibling && sibling.hasAttribute("_else")){

             
                
                if(sibling.hasAttribute("_if")){

                    ParserWarning(`
                    
                    The parser found an element which has simultaneousilly
                    the "_if" and "_else" attribute. It's forbidden.
                    
                    `)

                    return false;
                }

                setting.else=sibling;
                sibling.removeAttribute("_else");

   


            } if(setting.if){

                els.add(setting)


                

            }


        }
    }

    parseAttrs(theContainer)

        const reactor=runRenderingSystem(els, data);

        

        return reactor;
    

}



}


function runRenderingSystem(els, data){

    const toArray=Array.from(els);

    function run(source){

        for(const el of toArray){

            const{
                target,
                if:IF,
                else:ELSE,
                ifNot,
                i,
                root
            }=el;

            const current=getChildNodes(root)[i];


            if(ifNot){

                

               

                

                if(isFalse(source[ifNot]) && !target.isSameNode(current)){

                    

                    if(isANode(current)){

                        root.insertBefore(target, current)


                    }else{

                        root.appendChild(target);


                    }



                }else{

                    if(target.parentNode==root && isTrue(source[ifNot])){

                        root.removeChild(target);

                    }

                }

            }
            

            else if(isFalse(source[IF])){

                
                

              if(target.parentNode==root && !ELSE){   

             root.removeChild(target)

             

              }else if(ELSE){

                if(current && current.isSameNode(ELSE)){

                }else{

                    if(target.parentNode==root){

                root.replaceChild(ELSE,target);

                    }

                }

              }



            }else{
                
                
                 if(current){

                    const el=current;

                    
                     if(el.isSameNode(target)){
                       
                        if(ELSE && ELSE.parentNode!=null){


                            root.removeChild(ELSE)

                        }
                        
                    }
                    else if(ELSE && ELSE.parentNode!=null){

                        

                        root.replaceChild(target,ELSE)

                        

                    }
                    
                    else{

                    root.insertBefore(target,el);

                    }

                } 
         

                else{

                    

                    root.appendChild(target)

                }


            }


    

    }
    
}



const observer=new Map();
const proxyTarget=Object.assign({}, data);

run(proxyTarget);

const reactor=new Proxy(proxyTarget,{

    set(target, prop, value){

        if(!(prop in data) && prop!=="setConds"){
 
            consW(`
            "${prop}" was not defined 
            as a conditional property.
            
            `)

            return false;

        }

        if(!isBool(value) && prop!=="setConds"){

            err(`
            The values of all conditional properties must be either true or false,
            and not ${valueType(value)}
            `);

            return false;

        }

        Reflect.set(target, prop, value);


        if(prop!=="setConds"){

        run(proxyTarget);

        
        if(observer.size==1){


            const callBack=observer.get("callBack");

            callBack(prop, value);


        }

        }


        return true;

    },

    deleteProperty(...args){

        return false;

    }

})



Object.defineProperties(reactor,{ 
    observe:{

    value(fn){

        if(!isCallable(fn)){

            syErr(`
            The argument of [renderIf reactor].observe()
            must be a function.
            `)

        }

        if(observer.size==0){

            observer.set("callBack",fn);

            return true;

        };

        return false;



    },
    enumerable:!1,
    configurable:!1
    },
    setConds:{

        set(conditions){

            

            if(!isObj(conditions)){

                syErr(`
                
                The value of [renderIf reactor].setConds must be only
                a Javascript object, and you defined ${valueType(conditions)}
                as its value.

                `);

            };


            for(let [prop, cond] of Object.entries(conditions)){

                cond=isCallable(cond) ? cond.call(data) : cond;

            
                if(!isBool(cond)){
                    
                    err(`
                    All the values of conditional properties must be either true or false,
                    and not "${valueType(cond)}" as you defined.
                    
                    `)

                }

                if(!(prop in this)){

                    consW(`
                    
                    "${prop}" was not defined as conditional property.
                    
                    `)

                };


                    proxyTarget[prop]=cond;

                

            };



            run(proxyTarget);

        },
        enumerable:!1,
        configurable:!1

    }
})

return reactor;

}


  function toAttrs(obj){


    

    if(new.target!==void 0){

        syErr(`
        toAttrs is not a constructor,
        do not call it with the "new" keyword.
        
        `)

    }

    if(!isObj(obj)){
        
        syErr(`
        The argument of "toAttrs()" function must be an object.
        `)

    }

  const{
   
      in:IN,
      data,
      
  }=obj;

  if(!(typeof IN=="string")){

    syErr(`
    
    The "in" property value in toAttrs() function must be a string.
    
    `)

  }

  if(!isObj(data)){

    syErr(`

    The "data" property value in toAttrs() function must be an object.
  
    `)

  }
      
  
  const root=getId(IN)
          

  return findAttrManager(root,data);


 
}

 function findAttrManager(rootElem, attrManagers){
   
    const keys=Object.getOwnPropertyNames(attrManagers);
    const children=rootElem.getElementsByTagName("*");
    const reactors=Object.create(null);
    const isEmptyObj=o=>Object.keys(o).length==0;
    

    for(const child of children){
        
        if(child.attributes.length==1){
          
            
            const theAttr=child.attributes[0].name;
          
            for(const key of keys){

                if(!isObj(attrManagers[key])){

                    ParserWarning(`
                    
                    The value of the attribute manager "${key}" is not an object. It must
                    be a plain Javascript object.
                    
                    `);

                    continue;

                }

                if(isEmptyObj(attrManagers[key])){

                    ParserWarning(`
                    
                    The value of the attribute manager "${key}" is an empty object.
                    It must have at least one property.
                    
                    `)

                    continue;
                }
            
            if(("setAttrs" in attrManagers[key])){

                consW(`
                
                You can not use the "setAttrs" property as the property
                of an attribute manager, it's a reserved property, that's why
                Inter delete it from manager "${key}".
                
                `)

                delete attrManagers.setAttrs;

            }

        
            const pattern=new RegExp(`{...${key}}`);

            if(pattern.test(theAttr)){

              child.removeAttribute(theAttr);   

              const reactor=spread(child,key,attrManagers[key]);

              

              reactors[Object.keys(reactor)[0]]=Object.values(reactor)[0];
              
       
        
        }else{

            const isAnAttrManager=/{(:?\.){3}(:?[\s\S]+)}/.test(theAttr);
            const hasMoreThanThreeDots=/{(:?\.){4,}(:?[\s\S]+)}/.test(theAttr);
            const attr=theAttr.replace(/{(:?\.){3}/, "").replace("}", "");
            

            if(hasMoreThanThreeDots){

                ParserWarning(`
                
                "${theAttr}" is an invalid syntax for attribute manager.
                The attribute manager must have only three dots.

                Ex: {...managername}
                
                `)

            }
            if(isAnAttrManager && !attrManagers.hasOwnProperty(attr)){

            // The attribute manager <key> was not defined in toAttrs function,
            // but there is a reference to it in template.

            ParserWarning(`
            
            The attribute manager parser found a manager named "${attr}" but
            you did not defined it in the toAttrs function.
            
            `)
            

        }

    }
    }
    }




    
    }

    return reactors;
 }

    function spread(el, attrManager, attrs){

    //We are considering them specials
    // because we can not reset them with the setAttribute function.
    const specialAttrs=new Set(["value", "currentTime"]);
        
        function runUpdate(value, attrName){

            value=isCallable(value) ? value.call(attrs) : value;

            if(value==void 0){

                if(!attrName.startsWith("on")){

                    el.removeAttribute(attrName);

                }else{

                    el[attrName]=void 0;
                }

            }else if(!attrName.startsWith("on") && !specialAttrs.has(attrName) && el.getAttribute(attrName)!==value){

                  el.setAttribute(attrName,value);

                }else if(specialAttrs.has(attrName) && el[attrName]!==value){

                    el[attrName]=value;
                }
                
                else{

                    if(attrName.startsWith("On")){
                    
                    if(validDomEvent(attrName)){
                    if(!isCallable(value)){

                        syErr(`
                        The value of "${attrName}" event, must be a function.
                        `)
                    }

                    el[attrName]=function(e){

                        v.call(original,e)
                    }
                }else{

                    consW(`
                    
                    "${attrName}" doesn't seem to be a valid dom event.
                    
                    `)

                }

            }

        }
            }


        
        function defineReactivity(attrName){
            
            Object.defineProperty(attrs,attrName,{
                set(v){
                
                    runUpdate(v, attrName)

                },

                get(){
                   if(attrName.startsWith("on")){

                       consW(`
                       "${attrName}" seems to be an event listener, 
                       and you can not get the value of an event.
                       `)

                   }if(!specialAttrs.has(attrName)){
          
                     return el.getAttribute(attrName);

                     
                      
                   }else{

                    return el[attrName];

                   }
                }
            })
        
        
        }
        



        //<>//

         // Spreading the attributes.

         
         function spreadAttrs(attrName, attrValue){
            
            attrValue=!attrName.startsWith("on") ? isCallable(attrValue) ? attrValue.call(attrs) : attrValue : attrValue;

            if(attrValue!=void 0 && !specialAttrs.has(attrName) && !attrName.startsWith("on")){
           
            el.setAttribute(attrName,attrValue);

              }else if(attrValue!=void 0 && specialAttrs.has(attrName)){

                el[attrName]=attrValue;


              } else{
                
                if(attrName.startsWith("on")){
               if(validDomEvent(attrName)){
                if(!isCallable(attrValue)){

                    syErr(`
                    
                    The value of "${attrName}" must be a function.

                    `)

                }

                el[attrName]=function(e){

                     attrValue.call(attrs,e);
               
                   }
                
               
               }else{

                syErr(`
                
                "${attrName}" doesn't seem to be a valid dom event.
                
                `)

               }
              }

            }
           }

        for( const[attrName, attrValue] of Object.entries(attrs)){
             
            
            spreadAttrs(attrName, attrValue);
             defineReactivity(attrName);
            
        }

        //</>//

        Object.defineProperties(attrs, {

            setAttrs:{
                 set(__attrs){

                if(!isObj(__attrs)){

                    syErr(`
                    
                    The argument of [Attribute manager].setAttrs
                    must be an object.
                    
                    `)

                };

                for(const [attr, value] of Object.entries(__attrs)){

                    if(!(attr in this)){

                        consW(`
                        
                         The attribute manager "${attrManager}" 
                         does not manage an attribute named "${attr}",
                         all the attributes must be defined in the attrManager manager
                         object.
                        
                        `);

                        continue;

                    };

                    this[attr]=value;

                }

            },
            configurable:!1

        },

        [Symbol.toStringTag]:{
            value:()=>"Manager"
        }

        })

        return {
            [attrManager]:attrs
        };
        
        }



 function template(obj){

    

if(isObj(obj)){


    const temp=Symbol.for("template");

        return {

            [temp]:!0,
            element:obj,
            
        };




}else{

    syErr(`
    
    The argument of the template function must be a plain Javascript object,
    but you defined ${valueType(obj)} as its argument.
    
    `)

}


}



          function toDOM(obj, isChild){

    

            let {
                tag,
                text,
                renderIf,
                attrs={},
                events={},
                styles={},
                children=[],
            }=obj;

            
            
            
            tag=isCallable(tag) ? tag() : tag;

            if(isDefined(renderIf) && !isChild){

                

              ParserWarning(`
              
              You can not conditionally render a container in template
              function.
              
              `)

              return false;

            };

              if(!validTagOption(tag)){

                syErr(`
                
                "${valueType(tag)}" is an invalid tag's name, in template function.
                
                `)

              };

              if(!validStylesOrEventsOptions(events) || !validStylesOrEventsOptions(styles)){

                syErr(`
                
                The "events" and "styles" options in template function must be both plain Javascript objects.               
                `);

              }



              const container=document.createElement(tag);
              container.template=Object.assign(obj,{

                target:container

              }) // For diffing task.

              Object.entries(attrs).forEach((attr)=>{

                let [name, value]=attr;

                const setAttr=(attrValue)=>{
                    
                    if(isDefined(attrValue) && !isFalse(attrValue)){

                        if(name!=="value"){

                            container.setAttribute(name, attrValue)

                        }else{

                            container[name]=attrValue;

                        }

                    }

                }

                if(isCallable(value)){

                    value=value();

                    setAttr(value);


                }else{

                    setAttr(value);

                }

              })

               Object.entries(events).forEach(event => {

                const [name, handler]=event;

                     if(validDomEvent(name)){

                        if(isCallable(handler)){

                            container[name]=handler;
                            

                        }else{

                            ParserWarning(`
                            
                            The event "${name}" was not created because
                            its handler is not a function, in tempate function.
                            
                            `)

                        }

                     }else{

                        ParserWarning(`
                        
                        "${name}" doesn't seem to be a valid dom event.
                        
                        `)

                     }

                   
               });

               Object.entries(styles).forEach(style=>{

                const [name, value]=style;

                

                if(validStyleName(name)){

                    let styleValue=isCallable(value) ? value() : value;

                    if(isDefined(styleValue)){
                        
                        container.style[name]=styleValue;
                        

                    }

                }else{


                    ParserWarning(`
                    
                    "${name}" doesn't seem to be a valid style name.

                    `)

                }


               });

               if(isDefined(text) && children.length==0){


                const textContent=isCallable(text) ? createText(text()) : createText(text);

                container.appendChild(textContent);


               }else if(isDefined(text) && children.length>0){

                    consW(`
                    
                    It was found an element with both the text property and children property,
                    and in this case Inter ignores the text property.
                    
                    `);

                    createChildren(container, children);

                

               }else{

                if(children.length>0){


                    createChildren(container, children);

                }

               }

               


               return container;






}

function createChildren(root, children){


    for(const child of children){

        let {
            tag,
            text,
            attrs={},
            events={},
            styles={},
            children=[],
            renderIf,
        }=child;

        tag=isCallable(tag) ? tag() : tag;

        if(isDefined(renderIf) && isBool(renderIf)){
            

          if(isFalse(renderIf)){

            continue;

          }

        };


           
          if(!validTagOption(tag)){

            syErr(`
            
            "${tag}" is an invalid tag's name, in template function.
            
            `)

          };

          if(!validStylesOrEventsOptions(events) || !validStylesOrEventsOptions(styles)){

            syErr(`
            
            The "events" and "styles" options in template function must be both plain Javascript objects.               
            `);

          };

          
         




          const container=document.createElement(tag);
          container.template=Object.assign(child,{

             target:container

          }); //For diffing task.

          Object.entries(attrs).forEach((attr)=>{

            let [name, value]=attr;
            const setAttr=(attrValue)=>{
                
                if(isDefined(attrValue) && !isFalse(attrValue)){

                    if(name!=="value"){

                        container.setAttribute(name, attrValue)

                    }else{

                        container[name]=attrValue;

                    }

                }

            }

            if(isCallable(value)){

                value=value();

                setAttr(value);


            }else{

                setAttr(value);

            }

          })


           Object.entries(events).forEach(event => {

            const [name, handler]=event;

                 if(validDomEvent(name)){

                    if(isCallable(handler)){

                        container[name]=handler;
                        

                    }else{

                        ParserWarning(`
                        
                        The event "${name}" was not created because
                        its handler is not a function, in tempate function.
                        
                        `)

                    }

                 }else{

                    ParserWarning(`
                    
                    "${name}" doesn't seem to be a valid dom event.
                    
                    `)

                 }

               
           });

           Object.entries(styles).forEach(style=>{

            const [name, value]=style;
            

            if(validStyleName(name)){

                let styleValue=isCallable(value) ? value() : value;

                if(isDefined(styleValue)){

                    container.style[name]=styleValue;
                    

                }

            }else{


                ParserWarning(`
                
                "${name}" doesn't seem to be a valid style name.

                `)

            }


           });

           if(isDefined(text) && children.length==0){


            const textContent=isCallable(text) ? createText(text()) : createText(text);

            container.appendChild(textContent);


           }else if(isDefined(text) && children.length>0){

                consW(`
                
                It was found an element with both the text property and children property,
                and in this case Inter ignores the text property.
                
                `);

                createChildren(container, children);

            

           }else{

            if(children.length>0){


                createChildren(container, children);

            }

           }

           

           root.appendChild(container);


    }


    }





/**
 *  Reactive system for listing 
 *
 */

 function checkType(arg, call){

    if(isObj(arg)){

        defineReactiveObj(arg, call);

    }else if(isArray(arg)){

        defineReactiveArray(arg, call);

    }else if(isMap(arg)){

        defineReactiveMap(arg, call);

    }else{

        if(isSet(arg)){

            defineReactiveSet(arg, call);

        }

    }

 }


 
 function exactElToRemove(obj, key, root){

  
if(isObj(obj)){

    _inObj(obj, key, root);

}else if(isSet(obj)){

    _inSet(obj, key, root);

}else{

    _inMap(obj, key, root);

}
  


 }

 function _inObj(obj, key, root){

    const keys=Object.keys(obj);

    keys.some((prop,i)=>{

        if(prop==key){
    
           _Exactremove(root, i);
    
        }
    
      })

 }

 function _inSet(set, key, root){

    const obj=Array.from(set);
    

    obj.some((item, i)=>{

        if(item==key){

            _exactRemove(root, i);

        }

    })

 }

 function _inMap(obj, key, root){

    let i=-1;

    obj.forEach((value, prop)=>{

        i++;

        if(prop==key){

            _exactRemove(root, i);

        }

    })

    

 }

 function _exactRemove(root, i){

    const elToRmove=root.children[i];
    
    if(isAtag(elToRmove)){

        root.removeChild(elToRmove);

    }

 }

function createArrayReactor(each, updateSystem){


    if(isNotConfigurable(each)){

        err(`
        
        Inter fails to define the reactivity in the list reactor,
        because the array  of the each option is not configurable.
        
        `)

    }

    const costumProps=new Set(["otherArray", "addItems"]);

    return new Proxy(each, {

        set(target, prop, value){
          
            if(costumProps.has(prop)){

                Reflect.set(target, prop, value);
                return true;    
            }

            
            Reflect.set(target, prop, value);

            updateSystem();

            if(typeof prop !=="number" && validEachProperty(value)){

                

                checkType(value, updateSystem)

            }

            return true;


        },

        get(){


            return Reflect.get(...arguments);

        },

    })




}
    
function createObjReactor(each, updateSystem, root){

    if(isNotConfigurable(each)){

        err(`
        
        Inter fails to define the reactivity in the list reactor,
        because the array  of the each option is not configurable.
        
        `)

    }



    return new Proxy(each, {

        set(target, prop, value){
          

            Reflect.set(target, prop, value);

            updateSystem();

            if(typeof prop !=="number" && validEachProperty(value)){

                

                checkType(value, updateSystem)

            }

            return true;


        },

        get(){


            return Reflect.get(...arguments);

        },

        deleteProperty(target, prop){

            if(prop in target){

                exactElToRemove(target, prop, root)
                Reflect.deleteProperty(...arguments);
                updateSystem()
                

                return true;

            }

            consW(`
            You are trying to delete the "${prop}" property in the list
            reactor, but that property does not exist in the list reactor.
            
            `)

        }

    })




}

 function defineReactiveObj(obj, call){

    const reactive=Symbol.for("reactive"),
           reservedProps=new Set(["setProps","defineProps","deleteProps"]),
          share=Object.assign(Object.create(null), obj);

    if(reactive in obj){

        //The object is already reactive
        //So, we must skip all the task.

        return  false;

    }

    if(isNotConfigurable(obj)){

        consW(`
        
        Inter fails to define reactivity
        in a plain Javascript object because it is a non-configurable object.
        
        `);

        return false;

    }


    for(const prop of Object.keys(obj)){

        if(reservedProps.has(prop)){

        delete obj[prop];

        consW(`
        
        "${prop}" is a reserved property,
        do not create a property with this name in the reactor
        of reactive listing.
        
        `);

        

        }

        Object.defineProperty(obj, prop, {

            set(newValue){

                share[prop]=newValue;

                call();

            },

            get(){

                return share[prop];

            },
            configurable:!0

        })

    };

    Object.defineProperties(obj,{

        defineProps:{

            set(props){

                if(!isObj(props)){

                    syErr(`
                    
                    The value of [List reactor => Object.defineProps] must be
                    only a plain Javascript object, and you
                    defined "${valueType(props)}" as its value.
                    
                    `);

                };

                for(const [prop, value] of Object.entries(props)){

                    if(!(prop in this) && prop!=="defineProps" && prop!=="setProps"
                    && prop!=="removeProps" 
                    ){

                        share[prop]=value;

                    }

                };

                call();

            },
            enumerable:!1,
            configurable:!1

            

        },

        setProps:{

            set(props){

                if(!isObj(props)){


                    syErr(`
                    
                    The value of [Reactor].defineProps must be
                    only a plain Javascript object, and you
                    defined ${valueType(props)} as its value.
                    
                    `);

                };

                for(const [prop, value] of Object.entries(props)){

                    if(prop in this && prop!=="defineProps" && prop!=="setProps"
                    && prop!=="deleteProps"
                    ){

                        share[prop]=value;

                    }

                };

                call();

            },
            enumerable:!1,
            configurable:!1

        },
        deleteProps:{
            set(props){

                if(!isArray(props)){

                    syErr(`
                    
                    The value of [List reactor => Object.deleteprops] must be 
                    an array, and you defined "${valueType(props)}" as its value.
                    
                    `)

                };

                for(const prop of props){
                    

                    if(prop in this){

                        delete this[prop];

                    };

                };

                call();

            }
        },
        [reactive]:{
            get(){

                return true;

            }
        }

    })

 }

 function defineReactiveArray(array, call){

    const reactive=Symbol.for("reactive");

    if(reactive in array){

        return false;

    }

    const mutationMethods=[
        "push",
        "unshift",
        "pop",
        "shift",
        "splice",
        "sort",
        "reverse"
    ];

    for(const method of mutationMethods){

        Object.defineProperty(array, method, {

            value(start, deleteCount, ...items){

                Array.prototype[method].apply(this, arguments);

                if(method==="push" || method==="unshift"){

                    for(const arg of arguments){

                         checkType(arg)

                    }

                }else{

                    if(method==="splice" && isDefined(items)){

                        for(const item of items){

                            checkType(item);

                        }


                    }

                }

            }

        })

    };

    walkArray(array, call);

    Object.defineProperty(array, reactive, {

        value:true,

    })


 };

 function defineReactiveMap(map, call, listReactor, root){

    const reactive=Symbol.for("reactive");

    if(reactive in map){

        return false;

    }

    const mutationMethods=[

        "set",
        "delete",
        "clear"
         

    ];


    

    for(const method of mutationMethods){

        Object.defineProperty(map, method, {

            value(){

                if(method=="delete" && listReactor)exactElToRemove(this, arguments[0], root)
                Map.prototype[method].apply(this, arguments);
                if(method=="add"){

                    const value=arguments[1];

                    checkType(value);

                }

                call();

            }

        })

    }

    walkMap(map, call);

    Object.defineProperty(map, reactive, {

        value:true

    })

    

 }

 function defineReactiveSet(set, call, listReactor, root){

    const reactive=Symbol.for("reactive");

    if(reactive in set){

        return false;

    }

    const mutationMethods=[

        "add",
        "clear",
        "delete"


    ];

    for(const method of mutationMethods){

        Object.defineProperty(set, method, {

            value(){

                if(method=="delete" && listReactor)exactElToRemove(this, arguments[0], root);
                Set.prototype[method].apply(this,arguments);

                if(method==="add"){

                    checkType(arguments[0]);

                };

                call();

            }

        });

    };

    walkSet(set, call);

    Object.defineProperty(set, reactive, {

        value:true

    })
    

 }

 function walkMap(map, call){

    /**
     * The goal here is to iterate through the map collection
     * and if we found an object, an array, a set or even a map, we must make it reactive.
     * 
     */

     map.forEach((value)=>{

        checkType(value, call)


     })


 }

 function walkArray(array, call){

    for(const item of array){

        checkType(item, call);

    }

 }

 function walkSet(set, call){

    set.forEach((value)=>{

        checkType(value, call)

    })

 }

 const reactive=Symbol.for("reactive");

 function costumReactor(array, htmlEl, updateSystem, DO, pro){

    if(isNotConfigurable(array)){

        return false;

    }

    //It is already reactive array.
    if(reactive in array){

        return false;

    }


    // Is not returning the template.
    function runError(){

        syErr(`
                
        You are not returning the template function
        in "do" method, renderList, you must only return
        the template function.
        
        `)

    }
        

Object.defineProperties(array, {

    shift:{

    value(){  
    
    Array.prototype.shift.apply(array, void 0);
    const firstNodeElement=htmlEl.children[0];
    
    if(firstNodeElement){
    
    htmlEl.removeChild(firstNodeElement);
    
    
    updateSystem();
    
    }
    
    
    
    
    }

},
    

 unshift:{

        value(){
        
        
        Array.prototype.unshift.apply(array, arguments);
        

        if(arguments.length>1){
        
        
        let i=arguments.length-1;
        
        for(; i>-1; i--){
        
            
            const temp=DO.call(pro,arguments[i],i, pro);

            if(!isValidTemplateReturn(temp)){
                 
                runError();

            }
            if(htmlEl.children[0]){
            
                htmlEl.insertBefore(toDOM(temp.element), htmlEl.children[0]);
        
            }else{
        
                htmlEl.appendChild(toDOM(temp.element));
        
            }

        
        
        }
        
        }else if(arguments.length==1){
        
        const temp=DO.call(pro, arguments[0], 0, pro);
            
        if(!isValidTemplateReturn(temp)){
                 
            runError();

        }
        
        if(htmlEl.children[0]){
            
            htmlEl.insertBefore(toDOM(temp.element), htmlEl.children[0]);
        
        }else{
        
            htmlEl.appendChild(toDOM(temp.element));
        
        }
        
        
        
        }

        updateSystem();

        }
        
        
        
        
        
        
        
        },
        
        
        
         splice:{
        
        value(start, deleteCount, ...items){
        
        Array.prototype.splice.apply(array,arguments);
        
        
        if(items.length==0){
        
            let from=start;
            const to=deleteCount;
        
        /**
         * 4
         * 1
         * 
         */
            for(let i=0; i<to; i++){
        
                
                const node=htmlEl.children[from];
        
                if(node){
        
                htmlEl.removeChild(node)
        
                }
        
            }
        
        }else{
        
            
        
            if(deleteCount==0 && items){

                for(let l=items.length-1; l>-1; l--){
        
                    const temp=DO.call(pro, items[l], l, pro);
                    
                   if(!isValidTemplateReturn(temp)){
                 
                       runError();

                       }
        
                    if(htmlEl.children[start]){
        
                    htmlEl.insertBefore(toDOM(temp.element),htmlEl.children[start]);
        
                    }else{
        
                        htmlEl.appendChild(toDOM(temp.element));
        
                    }
        
                }
        
            }
        
        }
        
    
        
        
        updateSystem();
        
        }


    },
    [reactive]:{value:true}
        
         })
        
        



 }


 

 function renderList(options){

    

    if(new.target!==void 0){

        syErr(`
        
        renderList is not a constructor, do not call
        it with the "new" keyword.
        
        `);

    }

    if(!isObj(options)){

        syErr(`
        
        The options(the argument of renderList) in renderList must be a plain Javascript object.
        
        `)


    }

    let {
        in:IN,
        each,
        do:DO,
        
    }=options;

    const root=getId(IN)
     

    if(!validInProperty(IN)){

        syErr(`
        
        The "in" option in renderList must be either a string
        or an HTMLElement.
        
        `)

    }

    if(!validEachProperty(each)){

        syErr(`
  
        "${valueType(each)}" is not a valid value for the "each" options in renderList.
        The value that are accepted in "each" options, are:

        Array.
        Plain js object.
        Map.
        Set.

         
        `)

    }

    if(!isCallable(DO)){

        syErr(`
        
        The value of the "do" option in renderList, must be only a function.
        
        `)

    }


    let pro, firstRender=true;

    function proSetup(){

        

        if(isArray(each)){
            pro=createArrayReactor(each, updateSystem);
            
            costumReactor(each, root, updateSystem, DO, pro);
        }
        else if(isObj(each)){

            pro=createObjReactor(each, updateSystem, root);

        }
        else if(isSet(each)){

            defineReactiveSet(each, updateSystem, true, root);
            pro=each;

        } else{

             if(isMap(each)){

            defineReactiveMap(each, updateSystem, true, root);
            pro=each;

        }

    }

    }

    const defineNewEach=(newArray)=>{

        each=newArray;
        defineReactorReactiveProps(each, updateSystem);
        proSetup();
        updateSystem();
        
        

    }

    function defineReactorReactiveProps(){

        const reactive=Symbol.for("reactive");
    
        if(reactive in each){
          
            return false;
    
        }
    
        Object.defineProperties(each, {
    
            otherArray:{
                set(value){
                    
                    if(!isArray(value)){
    
                        syErr(`The value of [List reactor].otherArray property must be an object.`)
    
                    };
                      console.log(true)
                    
    
                    defineNewEach(value);
    
                    for(const item of value){
    
                        checkType(item, updateSystem)
    
                    }
    
    
                },
    
                configurable:!0
            },
            addItems:{
                value(items, position){
    
    
                    if(isDefined(position) && (typeof position!=="number")){
    
                        syErr(`
                        
                        The second argument of [LIST REACTOR].addItems must 
                        be a number.
                        
                        `)
    
                    }
    
                    
                    if(!isArray(items)){
    
                        syErr(`
                        
                        The first argument of [LIST REACTOR ].addItems must be an array.
                        
                        `)
    
                    }
    
                    if(!isDefined(position) || position>this.length-1){
    
                        for(const item of items){
    
                            
                            
                         this.push(item);
                         
                            
                         checkType(item, updateSystem);
    
                        }
    
                        
    
                    }
    
                    if(position==0 || position<0){
    
                        for(let i=items.length-1; i>-1 ;i-- ){
    
                            this.unshift(items[i]);
    
                            checkType(items[i], updateSystem);
    
                        }
    
                    }else{
    
                        for(const item of items){
    
                            this.splice(position, 0, item)
    
                        }
    
                    }
    
                },
                configurable:!0
            },
            
    
        })
    
    
    
    }
    
    if(isArray(each)){
    
        defineReactorReactiveProps();
    
    }

    

        proSetup();

        


    function updateSystem(){

        const i=new Iterable(each);
        

      syncronizeRootChildrenLengAndSourceLength(root, i);
    

      
    i.each((data, index, type)=>{
      

        let newTemp;
            
        
        function checkIterationSourceType(){

       if(type==="array"){

        newTemp=DO.call(pro, data, index, pro);

       }

        else if(type==="object"){

      newTemp=DO.call(pro ,data[0]/*prop*/,data[1]/*value*/,pro);


        }else if(type==="number"){

            newTemp=DO(data)

        }else{

            //The type is set.

        newTemp=DO.call(pro ,data,pro);

        }

    }

    checkIterationSourceType();

             // The  function is returning the template.
        if(isValidTemplateReturn(newTemp)){

            

            const actualEl=root.children[index];

            if(!isAtag(actualEl)){

                
                root.appendChild(toDOM(newTemp.element));

            }else{

                
                if(!actualEl.template){
                   
                    consW(`
                    
                    Avoid manipulating what Inter manipulates,
                    
                    `)
    
                    /**
                     * ActualEl was not rendered by Inter, in
                     * this case we must replace it with an element
                     * rendered by Inter to avoid diffing problems.
                     */
    
                     root.replaceChild(toDOM(newTemp.element), actualEl);
    
                    }else{
    
                        
    
                        runDiff(newTemp.element, actualEl.template, actualEl);
    
                    }
    
                }

            if(firstRender){
            checkType(type!=="object" ? data : data[1] /*obj prop*/, updateSystem);

            }

        

        }else{

            syErr(`
            
           The template function is not being returned inside the do method in
           renderList(reactive listing), just return the template function.
            
            `)

        }


    })

    


}

updateSystem()

firstRender=false;




return pro;




}




function runDiff(newTemp, oldTemp, oldRoot){


    /**
     * the update and the UpdateChildren
     * have high priority in the diffing.
     * 
     */

     
     const diff={
         children:true
     }



     ContainerDeffing(newTemp, oldTemp, diff)

     if(diff.children && newTemp.children && newTemp.children.length>0 ){

        
        diffingChildren(newTemp.children, oldTemp.children, oldRoot);

     };

     
     

    


}

function isOneAnArrayAndOtherNot(first, second){

    return (

        (isArray(first) && !isArray(second)) || (!isArray(first) && isArray(second))

    );

}

function AreBothArray(first,second){

    return isArray(first)  && isArray(second);

}

function ContainerDeffing(newContainer, oldContainer, diff){

    const {
        tag:newTag,
        text:newText,
        attrs:newAttrs={},
        events:newEvents={},
        styles:newStyles={},
        children:newChildren
    }=newContainer;

    const {
        tag:oldTag,
        text:oldText,
        attrs:oldAttrs={},
        events:oldEvents={},
        events:oldStyles={},
        children:oldChildren,
        target
    }=oldContainer;

    const rootEL=target.parentNode

    

     if(newTag!==oldTag){

        const newElement=toDOM(newContainer);

        rootEl.replaceChild(newElement,target);

        diff.children=false;

        shareProps(oldContainer, newContainer);
        oldContainer.target=newElement


        return true;

     }

     if(isOneAnArrayAndOtherNot(newChildren, oldChildren)){

        const newElement=toDOM(newContainer)

        rootEL.replaceChild(newELement, target);

        diff.children=false;
        shareProps(oldContainer, newContainer);
        oldContainer.target=newElement;

        return true;

     }

     if(AreBothArray(newChildren, oldChildren) && newChildren.length!==oldChildren.length){

        const newElement=toDOM(newContainer)

        rootEL.replaceChild(newElement, target);

        diff.children=false;
        shareProps(oldContainer, newContainer);
        oldContainer.target=newElement;

        return true;

     }

    if(!isDefined(newChildren) && !isDefined(oldChildren)){

        if(newText!==oldText){


            target.textContent=newText;
            
            shareProps(oldContainer, newContainer);

        }
    }

    
attributeDiffing(target, oldAttrs, newAttrs);
eventDeffing(target, oldEvents, newEvents);
styleDiffing(target, oldStyles, newStyles);

shareProps(oldAttrs, newAttrs);
shareProps(oldEvents, newEvents);
shareProps(oldStyles, newStyles);




}

function shareProps(target, source){

    Object.assign(target, source);

}



function getGreater(firstArray, secondArray){

    return firstArray.length>secondArray.length ? firstArray : secondArray;

}

function attributeDiffing(target, oldAttributes, newAttributes){

    const _old=Object.keys(oldAttributes),
          _new=Object.keys(newAttributes),
          _greater=getGreater(_old, _new);

    for(let i=0; _greater.length>i ; i++){

        const oldAttr=_old[i],
              newAttr=_new[i];
         
         if(!(oldAttr in newAttributes) || !isDefined(newAttributes[oldAttr]) || isFalse(newAttributes[oldAttr])){

            target.removeAttribute(oldAttr);

            

         }     

        if(isDefined(newAttributes[newAttr]) && !isFalse(newAttributes[newAttr])){

            if(newAttributes[newAttr]!==oldAttributes[newAttr]){

                target.setAttribute(newAttr, newAttributes[newAttr]);

            }


        }

    }

};

function styleDiffing(target, oldStyles, newStyles){


    const _old=Object.keys(oldStyles),
    _new=Object.keys(newStyles),
    _greater=getGreater(_old, _new);

for(let i=0; _greater.length>i ; i++){

  const oldStyle=_old[i],
        newStyle=_new[i];
    
   if(!(oldStyle in newStyles) || !isDefined(newStyles[oldStyle])){

        target.style.removeProperty(oldStyle)
        _new.splice(i,1);
        if(_new.length==0){

            target.removeAttribute("style");

        }

      

   }     

  if(isDefined(newStyles[newStyle])){

      if(newStyles[newStyle]!==oldStyles[newStyle]){

          if(validStyleName(newStyle)){

          target.style[newStyle]=newStyles[newStyle];

      }else{

        ParserWarning(`
        
        "${newStyle}" doesn't seem to be a valid style name.
        
        `)

      }
    }


  }

}

    
}


function eventDeffing(target, oldEvents, newEvents){

    const _old=Object.keys(oldEvents),
    _new=Object.keys(newEvents),
    _greater=getGreater(_old, _new);

   for(let i=0; _greater.length>i ; i++){

  const oldEvent=_old[i],
        newEvent=_new[i];
    
   if(!(oldEvent in newEvents) || !isDefined(newEvents[oldEvent])){

      target[oldEvent]=void 0;

   }     

  if(isDefined(newEvents[newEvent])){

    if(validDomEvent(newEvent)){

    target[newEvent]=newEvents[newEvent];

    }else{

        ParserWarning(`
        
        "${newEvent}" doesn't seem to be a valid dom event.
        
        `)

    }

  }

}



}

function diffingChildren(__new, __old, realParent){

    const _new=Array.from(__new),
    _old=Array.from(__old);
    let removed=0;

    for(let i=0; i<_new.length; i++){

        
        
     /**
      * {tag:"h2"}  {tag:"h2"}
      * {tag:null} {tag:null}
      * {tag:"button"} {tag:"button"}
      * 
      */

        const newChild=_new[i],
              oldChild=_old[i];
              

    
        const {
            tag:newTag,
            text:newText,
            children:newChildren=[],
            events:newEvents={},
            attrs:newAttrs={},
            styles:newStyles={},
            renderIf:newRenderIf
            
        }=newChild;
        
       const {
        tag:oldTag,
        text:oldText,
        children:oldChildren=[],
        events:oldEvents={},
        attrs:oldAttrs={},
        styles:oldStyles={},
        target   

       }=oldChild;

       if(newChildren.length!==oldChildren.length){

                if(target && target.parentNode!=null){

                    const newElement=toDOM(newChild, true);

                     realParent.replaceChild(newElement, target);

                     Object.assign(oldChild, newChild);
                      oldChild.target=newElement
                
            }

                
                continue;

            }else{


                if(newTag!==oldTag){

                        
                    const newELement=toDOM(newChild, true);

                    Object.assign(oldChild, newChild);

                    if(target && target.parentNode!=null){

                        realParent.replaceChild(newELement, target);
                        oldChild.target=newELement;

                    }

                    

                    continue
                    
             
                }


                if(isFalse(newRenderIf)){

                    if(target && target.parentNode!=null){

                    realParent.removeChild(target);

                    if(i<_new.length-1){
                    
                    i--;
                    removed++;

                    }

                }else{

                    removed++;

                }
                    
                 

                }

                
                if(isTrue(newRenderIf)){
                    

                    if(target && target.parentNode==null){

                        
                        const newELement=toDOM(newChild, true);

                        Object.assign(oldChild, newChild);

                        oldChild.target=newELement

                    if(isAtag(realParent.children[i-removed])){

                        realParent.insertBefore(newELement, realParent.children[i-removed]);

                    }else{

                        realParent.appendChild(newELement)


                    }

                    continue;
                    

                }



                if(!target){


                    if(isAtag(realParent.children[i-removed])){

                        const newELement=toDOM(newChild, true);

                        Object.assign(oldChild, newChild);

                        oldChild.target=newELement

                        console.log(i-removed)
                        realParent.insertBefore(newELement, realParent.children[i-removed]);

                    }else{

                        
                        const newELement=toDOM(newChild, true);

                        Object.assign(oldChild, newChild);

                        oldChild.target=newELement
                          
                        realParent.appendChild(newELement)

                    }

                }

                }


                if(newChildren.length==oldChildren.length && newChildren.length!==0){

                    

                    diffingChildren(newChildren, oldChildren, target);

                    continue;

                }

                
                if(oldText!==newText && target){

                    target.textContent=newText
                    oldChild.text=newText



                }

                


                Object.assign(oldChild, newChild)
                oldChild.tag=oldTag
                
               if(target){                
                attributeDiffing(target, oldAttrs, newAttrs);
                styleDiffing(target, oldStyles, newStyles);
                eventDeffing(target, oldEvents, newEvents);
               }
                

            }

            
        }
    }
    
    function syncronizeRootChildrenLengAndSourceLength(root, iterable){

        if(root.children.length>iterable.source.values.length){
    
            let length=root.children.length-iterable.source.values.length
    
                   while(length--){
    
                    root.removeChild(root.children[length]);
    
                   }
    
                }
    
    };

function toObj(obj){

    /**
     * We will try to convert obj(if it's actually a JSON Object) to a plain object,
     * if it fails we must return the obj argument.
     * 
     */

    if(obj!==void 0){

        try{


            return JSON.parse(obj);

        }catch(e){


            return obj;

        }


    }

}


function openRequest(req, method,path, username, userpassword ){

    if(username && userpassword){

        req.open(method, path, true, username, userpassword);

    }else{

        req.open(method, path, true, username, userpassword);

    }

}


 function Backend(){

    if(new.target===void 0){


        err(`Backend is a constructor, call it with the new keyword.`)


    }



}


Backend.prototype={

   get [Symbol.toStringTag](){

       return "Ajax";

   },

   request(obj){

       if(!isObj(obj)){

        syErr(`
        
        The argument of [Backend instance].request method
        must be only an object, and you defined "${valueType(obj)}"
        as its argument.
        
        `)


       }

       const{
           type,
           path,
           events={},
           timeout,
           withCredentials,
           body=null,
           headers={},
           security
       }=obj;

       if(!isDefined(type) || typeof type!=="string"){

        syErr(`
        
        You must define the type of request, in Ajax with the "type" option and
        it must be a string.
        
        `)

       }

       if(!isDefined(path) || typeof path!=="string"){

        syErr(`
        
        You must define the path where the request will be sent, with the "path" option and 
        it must be a string.
        
        `)

       }

       const reactorHandler=new Map();
       let requestOpened=false;



       function call(){

       const req=new XMLHttpRequest();
       const method=type.toUpperCase();
       const allowedEvents=new Set([
           "onprogress",
           "ontimeout",
           "onabort"
       ])

       
       const _AjaxResponse={

          get status(){

            return req.status;

          },

          get statusText(){

            return req.statusText;

          },

          get headers(){

            return req.getAllResponseHeaders();

          },

          get data(){

            return toObj(req.responseText);

          },

          get [Symbol.toStringTag](){

            return "AjaxResponse";

          },

          isObj(){

            try{

                JSON.parse(req.responseText);

                return true;

            }catch(e){

                return false;

            }

          }

       }       

       
     
           
           if(isObj(security) && Object.keys(security).length>=2){

            if(security.username && security.password){

                openRequest(req, method, path, security.username, security.password);

                requestOpened=true;

            }else{

                consW(`
               
                Invalid "security" object, security object must have the username and passoword 
                properties.
                
                `)

            }
            
           }

           if(!requestOpened){

            openRequest(req, method, path)

            requestOpened=true;



           }



       
      

       

       
       if(!isObj(headers)){


           syErr(`
           
           the "headers" property must be an object, and
           you defined it as : ${valueType(headers)}.
           
           `)


       }


       Object.entries(headers).forEach(([header,value])=>{

          req.setRequestHeader(header,value);


       })

       Object.entries(events).forEach(([name,handler])=>{

           if(allowedEvents.has(name)){

               if(name!=="onprogress"){

                   req[name]=()=>{

                       handler();
                   }

               }else{

                   req.onprogress=(ev)=>{

                    const Arg={abort:()=>req.abort(), progress:ev.loaded*100/ev.total}

                       handler(Arg);

                   }

               }

           }else{

            consW(`
            
            There's not any event named "${name}" in Ajax request.
            
            `)

           }

       })


       req.onreadystatechange=function(e){

           if(this.readyState==4){


            if(this.status==200){


                if(reactorHandler.has("okay")){

                    reactorHandler.get("okay")(_AjaxResponse)

                }


            }else{

                if(reactorHandler.has("error")){

                    reactorHandler.get("okay")(_AjaxResponse);

                }

            }


           }else{

            /**
             *  
             * If it runs probably because there was an internet connection error
             * like: "no internet"
             * 
             * The request was not sent to the server, the error reactor must be called.
             * 
             */


             if(reactorHandler.has("error")){
             
                const _resp={

                    isObj:()=>false,
                    get statusText(){

                        return "No Internet connection"

                    },

                    get status(){

                        return 0

                    },

                    get headers(){

                        return new String();

                    },

                    get data(){

                        return void 0;

                    },

                    get [Symbol.toStringTag](){

                        return "AjaxResponse";

                    }

                }

                reactorHandler.get("error")(_resp);

             }


           }

       }

       if(typeof withCredentials=="boolean"){

        req.withCredentials=withCredentials;
        

       }

       if(typeof timeout=="number"){

        req.timeout=timeout;

       }


       req.send(body);


   }



       const reactors={


           okay(fn){

            if(!isCallable(fn)){

                syErr(`
                
                The argument of okay reactor must be a function
                and you defined ${valueType(fn)} as its argument
                
                `)

            }

            reactorHandler.set("okay", fn);
            //Starting the request...
            call();



           },

           error(fn){

            if(!isCallable(fn)){


                syErr(`
                
                The argument of error reactor must be a function, and you
                defined ${valueType(fn)} as its argument.
                
                `)


            }


            reactorHandler.set("error", fn);
            //Starting the request...
            call();


           },

           
           response(okay,error){

            if(arguments.length<2){

                syErr(`
                
                response reactor must have two arguments and you only
                defined ${arguments.length}.
                
                `)

            }
            if(!isCallable(okay) && !isCallable(error)){


                syErr(`
                
                The two arguments of response handler must be functions.
                
                
                `)

            }

            reactorHandler.set("okay", okay);
            reactorHandler.set("error", error);
            //Starting the request...
            call();

           }

       }

       return reactors;
       

   }

}


Object.freeze(Backend.prototype);

 window.Ref=Ref;
 window.renderIf=renderIf;
 window.toAttrs=toAttrs;
 window.renderList=renderList;
 window.template=template;
 window.Backend=Backend;

})();

